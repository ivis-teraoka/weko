GLOB sdist-make: /code/modules/weko-workflow/setup.py
c1 recreate: /code/modules/weko-workflow/.tox/c1
c1 installdeps: pytest>=3, pytest-cov, -rrequirements2.txt
c1 inst: /code/modules/weko-workflow/.tox/.tmp/package/1/weko-workflow-0.1.0.dev20170000.zip
c1 installed: alabaster==0.7.13,alembic==0.9.6,amqp==2.6.0,angular-gettext-babel==0.3,aniso8601==8.0.0,arrow==0.12.1,asn1crypto==0.23.0,atomicwrites==1.4.1,attrs==17.4.0,b2handle==1.1.2,Babel==2.5.1,bagit==1.7.0,beautifulsoup4==4.9.3,bibtexparser==1.0.1,billiard==3.6.3.0,binaryornot==0.4.4,bleach==3.1.0,blinker==1.4,boto3==1.7.84,botocore==1.10.84,cachelib==0.1,cachetools==4.2.4,cchardet==2.1.1,celery==4.4.4,certifi==2017.11.5,cffi==1.11.2,chardet==3.0.4,citeproc-py==0.5.1,citeproc-py-styles==0.1.2,click==6.7,cookiecutter==1.6.0,counter-robots==2018.6,coverage==6.2,cryptography==2.1.4,datacite==1.0.1,DateTime==4.9,decorator==4.1.2,defusedxml==0.5.0,dictdiffer==0.7.0,distlib==0.3.6,dnspython==2.2.1,docutils==0.18.1,dojson==1.3.2,elasticsearch==6.1.1,elasticsearch-dsl==6.4.0,elementpath==1.0.6,email-validator==1.0.5,entrypoints==0.2.3,feedgen==0.7.0,filelock==3.4.1,Flask==1.1.0,Flask-Admin==1.5.3,Flask-Alembic==2.0.1,Flask-Assets==0.12,Flask-BabelEx==0.9.4,Flask-Breadcrumbs==0.5.0,Flask-Caching==1.10.1,Flask-CeleryExt==0.3.4,Flask-Collect==1.2.2,Flask-Cors==3.0.3,Flask-DebugToolbar==0.13.1,Flask-IIIF==0.6.1,Flask-KVSession==0.6.2,Flask-Limiter==1.1.0,Flask-Login==0.4.1,Flask-Mail==0.9.1,flask-marshmallow==0.14.0,Flask-Menu==0.6.0,-e git+https://github.com/RCOSDP/flask-oauthlib.git@d47fafb1558e261f98ca916355346a9ca7b4a68e#egg=Flask_OAuthlib,Flask-Plugins==1.6.1,Flask-Principal==0.4.0,Flask-RESTful==0.3.8,Flask-Security==3.0.0,flask-shell-ipython==0.4.1,Flask-Sitemap==0.4.0,Flask-SQLAlchemy==2.3.2,flask-talisman==0.4.1,Flask-WTF==0.14.3,-e git+https://github.com/RCOSDP/pyfpdf.git@f9b032148283d535cabc7789858081c80de36fef#egg=fpdf,frozendict==2.3.8,fs==0.5.4,ftfy==4.4.3,future==0.16.0,github3.py==1.1.0,html5lib==1.0.1,idna==2.6,iiif-prezi==0.3.0,imagesize==1.4.1,importlib-metadata==4.8.3,importlib-resources==5.4.0,infinity==1.4,iniconfig==1.1.1,intervals==0.8.0,invenio-access==1.1.0,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_accounts&subdirectory=modules/invenio-accounts,invenio-admin==1.1.2,invenio-app==1.1.0,invenio-assets==1.0.0,invenio-base==1.0.2,invenio-cache==1.0.0,invenio-celery==1.1.3,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_communities&subdirectory=modules/invenio-communities,invenio-config==1.0.0,invenio-csl-rest==1.0.0a1,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_db&subdirectory=modules/invenio-db,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_deposit&subdirectory=modules/invenio-deposit,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_files_rest&subdirectory=modules/invenio-files-rest,invenio-formatter==1.0.0b3,invenio-i18n==1.0.0,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_iiif&subdirectory=modules/invenio-iiif,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_indexer&subdirectory=modules/invenio-indexer,invenio-jsonschemas==1.0.0,invenio-logging==1.0.0b3,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_mail&subdirectory=modules/invenio-mail,invenio-marc21==1.0.0a8,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_oaiharvester&subdirectory=modules/invenio-oaiharvester,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_oaiserver&subdirectory=modules/invenio-oaiserver,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_oauth2server&subdirectory=modules/invenio-oauth2server,invenio-oauthclient==1.0.0,invenio-pidrelations==1.0.0a4,invenio-pidstore==1.0.0,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_previewer&subdirectory=modules/invenio-previewer,invenio-query-parser==0.6.0,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_queues&subdirectory=modules/invenio-queues,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_records&subdirectory=modules/invenio-records,invenio-records-files==1.0.0a10,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_records_rest&subdirectory=modules/invenio-records-rest,invenio-records-ui==1.0.0,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_resourcesyncclient&subdirectory=modules/invenio-resourcesyncclient,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_resourcesyncserver&subdirectory=modules/invenio-resourcesyncserver,invenio-rest==1.1.2,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_s3&subdirectory=modules/invenio-s3,-e git+https://github.com/RCOSDP/invenio-search.git@cff9744c5dc651893a9c51672c5b8da9adc21e16#egg=invenio_search,-e git+https://github.com/RCOSDP/invenio-search-ui.git@74bd3b2990ff27b39e01b6b31be9a0b5fda3dd0f#egg=invenio_search_ui,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=invenio_stats&subdirectory=modules/invenio-stats,invenio-theme==1.0.0b4,ipaddress==1.0.19,ipython==6.2.1,ipython-genutils==0.2.0,itsdangerous==0.24,jedi==0.11.0,Jinja2==2.10.1,jinja2-cli==0.6.0,jinja2-time==0.2.0,jmespath==0.10.0,jsmin==2.2.2,jsonpatch==1.21,jsonpath-ng==1.5.2,jsonpointer==1.14,jsonref==0.1,jsonresolver==0.2.1,jsonschema==2.6.0,jupyter-client==5.2.2,jupyter-core==4.4.0,-e git+https://github.com/RCOSDP/kombu.git@f204fdf078d5e94393c86693f545e2d011f620f5#egg=kombu,limits==1.2.1,lxml==4.1.1,Mako==1.0.7,MarkupSafe==1.1.1,marshmallow==2.20.1,marshmallow-sqlalchemy==0.23.1,maxminddb==1.5.2,maxminddb-geolite2==2017.803,mistune==0.8.3,mock==5.0.2,more-itertools==8.10.0,msgpack==0.6.2,nbconvert==5.3.1,nbformat==4.4.0,netaddr==0.8.0,node-semver==0.1.1,numpy==1.16.1,oauthlib==2.1.0,ordereddict==1.1,packaging==21.3,pandocfilters==1.4.2,parso==0.1.0,passlib==1.7.1,pbr==5.11.1,pexpect==4.3.0,pickleshare==0.7.4,Pillow==5.4.1,platformdirs==2.4.0,pluggy==0.13.1,ply==3.11,poyo==0.4.1,prompt-toolkit==1.0.15,psycopg2==2.7.3.2,ptyprocess==0.5.2,py==1.11.0,pycparser==2.18,Pygments==2.2.0,PyJWT==1.5.3,PyLD==2.0.3,pyparsing==3.1.0,-e git+https://github.com/RCOSDP/PyPDF2.git@fefc684a3a74aff6f99e5dff24f9b4dd1c95169d#egg=PyPDF2,pyPEG2==2.15.2,pytest==6.1.2,pytest-cov==4.0.0,pytest-flask==0.15.1,pytest-invenio==1.3.1,pytest-mock==3.6.1,python-dateutil==2.6.1,python-editor==1.0.3,python-geoip==1.2,pytz==2017.3,pyzmq==17.0.0,redis==2.10.6,requests==2.18.4,requests-oauthlib==1.1.0,resync==1.0.9,s3fs==0.1.6,s3transfer==0.1.13,selenium==3.141.0,Sickle==0.6.4,simplegeneric==0.8.1,simplejson==3.12.0,simplekv==0.11.2,six==1.16.0,snowballstemmer==2.2.0,soupsieve==2.3.2.post1,speaklater==1.3,Sphinx==1.8.4,sphinxcontrib-serializinghtml==1.1.5,sphinxcontrib-websupport==1.2.4,SQLAlchemy==1.2.19,SQLAlchemy-Continuum==1.3.6,SQLAlchemy-Utils==0.35.0,stevedore==3.5.2,sword3common==0.1.1,testpath==0.3.1,toml==0.10.2,tomli==1.2.3,tornado==4.5.3,tox==3.28.0,traitlets==4.3.2,typing_extensions==4.1.1,ua-parser==0.7.3,uritemplate==4.1.1,uritools==2.1.0,urllib3==1.22,uWSGI==2.0.21,uwsgitop==0.11,validators==0.12.0,vine==1.3.0,virtualenv==20.17.1,virtualenv-clone==0.5.7,virtualenvwrapper==4.8.4,Wand==0.6.1,wcwidth==0.1.7,webargs==5.5.2,webassets==0.12.1,webencodings==0.5.1,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_accounts&subdirectory=modules/weko-accounts,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_admin&subdirectory=modules/weko-admin,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_authors&subdirectory=modules/weko-authors,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_bulkupdate&subdirectory=modules/weko-bulkupdate,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_deposit&subdirectory=modules/weko-deposit,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_gridlayout&subdirectory=modules/weko-gridlayout,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_groups&subdirectory=modules/weko-groups,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_handle&subdirectory=modules/weko-handle,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_index_tree&subdirectory=modules/weko-index-tree,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_indextree_journal&subdirectory=modules/weko-indextree-journal,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_items_autofill&subdirectory=modules/weko-items-autofill,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_items_ui&subdirectory=modules/weko-items-ui,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_itemtypes_ui&subdirectory=modules/weko-itemtypes-ui,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_logging&subdirectory=modules/weko-logging,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_records&subdirectory=modules/weko-records,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_records_ui&subdirectory=modules/weko-records-ui,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_redis&subdirectory=modules/weko-redis,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_schema_ui&subdirectory=modules/weko-schema-ui,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_search_ui&subdirectory=modules/weko-search-ui,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_sitemap&subdirectory=modules/weko-sitemap,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_swordserver&subdirectory=modules/weko-swordserver,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_theme&subdirectory=modules/weko-theme,-e git+https://mhaya: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@github.com/RCOSDP/weko.git@89a21fbe67458a8c9fe765be547cd4feb5598557#egg=weko_user_profiles&subdirectory=modules/weko-user-profiles,weko-workflow @ file:///code/modules/weko-workflow/.tox/.tmp/package/1/weko-workflow-0.1.0.dev20170000.zip,Werkzeug==0.15.2,whichcraft==0.4.1,WTForms==2.1,WTForms-Alchemy==0.16.5,WTForms-Components==0.10.3,xmlschema==0.9.30,xmltodict==0.12.0,zipp==3.6.0,zope.interface==5.5.2
c1 run-test-pre: PYTHONHASHSEED='3480473277'
c1 run-test: commands[0] | pytest --cov=weko_workflow tests -v -s -vv --cov-branch --cov-report=term --cov-report=xml --cov-report=html --cov-config=tox.ini --basetemp=/code/modules/weko-workflow/.tox/c1/tmp
============================= test session starts ==============================
platform linux -- Python 3.6.15, pytest-6.1.2, py-1.11.0, pluggy-0.13.1 -- /code/modules/weko-workflow/.tox/c1/bin/python
cachedir: .tox/c1/.pytest_cache
rootdir: /code/modules/weko-workflow
plugins: celery-4.4.4, flask-0.15.1, cov-4.0.0, mock-3.6.1, invenio-1.3.1
collecting ... collected 448 items

tests/test_admin.py::TestFlowSettingView::test_index_acl_guest PASSED
tests/test_admin.py::TestFlowSettingView::test_index_acl[0-403] PASSED
tests/test_admin.py::TestFlowSettingView::test_flow_detail_acl_guest PASSED
tests/test_admin.py::TestFlowSettingView::test_flow_detail_acl[1-200] FAILED
tests/test_admin.py::TestFlowSettingView::test_get_specified_properties PASSED
tests/test_admin.py::TestFlowSettingView::test_update_flow FAILED
tests/test_admin.py::TestFlowSettingView::test_new_flow FAILED
tests/test_admin.py::TestFlowSettingView::test_del_flow FAILED
tests/test_admin.py::TestFlowSettingView::test_get_actions FAILED
tests/test_admin.py::TestFlowSettingView::test_upt_flow_action FAILED
tests/test_admin.py::TestWorkFlowSettingView::test_index_acl_guest PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_index_acl[1-200] PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_workflow_detail_acl_guest PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_workflow_detail_acl[1-200] PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_update_workflow_acl_guest PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_update_workflow_acl[1-200] FAILED
tests/test_admin.py::TestWorkFlowSettingView::test_delete_workflow_acl_guest PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_delete_workflow_acl[1-200] PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_get_name_display_hide PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_get_displays PASSED
tests/test_admin.py::TestWorkFlowSettingView::test_save_workflow_role FAILED
tests/test_admin.py::TestWorkFlowSettingView::test_get_language_workflows FAILED
tests/test_api.py::test_Flow_action PASSED
tests/test_api.py::test_WorkActivity_filter_by_date PASSED
tests/test_api.py::test_WorkActivity_get_all_activity_list PASSED
tests/test_api.py::test_WorkActivity_get_activity_index_search FAILED
tests/test_api.py::test_WorkActivity_upt_activity_detail FAILED
tests/test_api.py::test_WorkActivity_get_corresponding_usage_activities PASSED
tests/test_cli.py::test_workflow PASSED
tests/test_cli.py::test_init_workflow_tables FAILED
tests/test_romeo.py::test_search_romeo_jtitles PASSED
tests/test_romeo.py::test_search_romeo_issn PASSED
tests/test_romeo.py::test_search_romeo_jtitle PASSED
tests/test_sessions.py::test_upt_activity_item PASSED
tests/test_tasks.py::test_cancel_expired_usage_report_activities ERROR
tests/test_utils.py::test_get_current_language PASSED
tests/test_utils.py::test_get_term_and_condition_content PASSED
tests/test_utils.py::test_get_identifier_setting PASSED
tests/test_utils.py::test_saving_doi_pidstore PASSED
tests/test_utils.py::test_register_hdl PASSED
tests/test_utils.py::test_item_metadata_validation tts:<PersistentIdentifier recid:1 / rec:0e490712-9351-4694-9981-994c014b5364 (R)>
tt4.1
PASSED
tests/test_utils.py::test_merge_doi_error_list PASSED
tests/test_utils.py::test_validation_item_property FAILED
tests/test_utils.py::test_handle_check_required_data PASSED
tests/test_utils.py::test_handle_check_required_pattern_and_either FAILED
tests/test_utils.py::test_check_required_data PASSED
tests/test_utils.py::test_get_activity_id_of_record_without_version PASSED
tests/test_utils.py::test_check_suffix_identifier PASSED
tests/test_utils.py::test_get_sub_item_value PASSED
tests/test_utils.py::test_get_item_value_in_deep PASSED
tests/test_utils.py::test_delete_bucket FAILED
tests/test_utils.py::test_merge_buckets_by_records[True] PASSED
tests/test_utils.py::test_merge_buckets_by_records[False] PASSED
tests/test_utils.py::test_merge_buckets_by_records_error PASSED
tests/test_utils.py::test_set_bucket_default_size FAILED
tests/test_utils.py::test_is_show_autofill_metadata PASSED
tests/test_utils.py::test_is_hidden_pubdate PASSED
tests/test_utils.py::test_get_parent_pid_with_type FAILED
tests/test_utils.py::test_filter_all_condition PASSED
tests/test_utils.py::test_filter_condition PASSED
tests/test_utils.py::test_get_actionid PASSED
tests/test_utils.py::test_convert_record_to_item_metadata PASSED
tests/test_utils.py::test_prepare_edit_workflow PASSED
tests/test_utils.py::test_handle_finish_workflow FAILED
tests/test_utils.py::test_delete_cache_data PASSED
tests/test_utils.py::test_update_cache_data PASSED
tests/test_utils.py::test_get_cache_data PASSED
tests/test_utils.py::test_check_an_item_is_locked PASSED
tests/test_utils.py::test_get_accoutn_info PASSED
tests/test_utils.py::test_check_existed_doi PASSED
tests/test_utils.py::test_get_url_root FAILED
tests/test_utils.py::test_get_record_by_root_ver PASSED
tests/test_utils.py::test_get_disptype_and_ver_in_metainfo PASSED
tests/test_utils.py::test_set_files_display_type PASSED
tests/test_utils.py::test_get_thumbnails PASSED
tests/test_utils.py::test_get_allow_multi_thumbnail PASSED
tests/test_utils.py::test_is_usage_application_item_type PASSED
tests/test_utils.py::test_is_usage_application PASSED
tests/test_utils.py::test_send_mail_reminder PASSED
tests/test_utils.py::test_send_mail_approval_done PASSED
tests/test_utils.py::test_send_mail_registration_done PASSED
tests/test_utils.py::test_send_mail_request_approval PASSED
tests/test_utils.py::test_send_mail PASSED
tests/test_utils.py::test_email_pattern_registration_done PASSED
tests/test_utils.py::test_email_pattern_request_approval PASSED
tests/test_utils.py::test_email_pattern_approval_done PASSED
tests/test_utils.py::test_get_mail_data PASSED
tests/test_utils.py::test_get_subject_and_content PASSED
tests/test_utils.py::test_get_file_path PASSED
tests/test_utils.py::test_replace_characters PASSED
tests/test_utils.py::test_register_info PASSED
tests/test_utils.py::test_get_approval_dates PASSED
tests/test_utils.py::test_get_item_info FAILED
tests/test_utils.py::test_get_site_info_name PASSED
tests/test_utils.py::test_get_default_mail_sender PASSED
tests/test_utils.py::test_set_mail_info PASSED
tests/test_utils.py::test_process_send_reminder_mail PASSED
tests/test_utils.py::test_process_send_notification_mail PASSED
tests/test_utils.py::test_get_application_and_approval_date PASSED
tests/test_utils.py::test_get_workflow_item_type_names PASSED
tests/test_utils.py::test_create_usage_report PASSED
tests/test_utils.py::test_create_record_metadata PASSED
tests/test_utils.py::test_modify_item_metadata PASSED
tests/test_utils.py::test_replace_title_subitem PASSED
tests/test_utils.py::test_get_schema_dict PASSED
tests/test_utils.py::test_create_deposit PASSED
tests/test_utils.py::test_update_activity_action PASSED
tests/test_utils.py::test_check_continue PASSED
tests/test_utils.py::test_autofill_title PASSED
tests/test_utils.py::test_exclude_admin_workflow PASSED
tests/test_utils.py::test_is_enable_item_name_link PASSED
tests/test_utils.py::test_save_activity_data PASSED
tests/test_utils.py::test_send_mail_url_guest_user PASSED
tests/test_utils.py::test_generate_guest_activity_token_value PASSED
tests/test_utils.py::test_init_activity_for_guest_user PASSED
tests/test_utils.py::test_send_usage_application_mail_for_guest_user PASSED
tests/test_utils.py::test_validate_guest_activity_token PASSED
tests/test_utils.py::test_validate_guest_activity_expired PASSED
tests/test_utils.py::test_create_onetime_download_url_to_guest PASSED
tests/test_utils.py::test_delete_guest_activity PASSED
tests/test_utils.py::test_get_activity_display_info PASSED
tests/test_utils.py::test___init_activity_detail_data_for_guest FAILED
tests/test_utils.py::test_prepare_data_for_guest_activity PASSED
tests/test_utils.py::test_recursive_get_specified_properties PASSED
tests/test_utils.py::test_get_approval_keys PASSED
tests/test_utils.py::test_process_send_mail PASSED
tests/test_utils.py::test_cancel_expired_usage_reports PASSED
tests/test_utils.py::test_process_send_approval_mails PASSED
tests/test_utils.py::test_get_usage_data PASSED
tests/test_utils.py::test_update_approval_date PASSED
tests/test_utils.py::test_create_record_metadata_for_user PASSED
tests/test_utils.py::test_get_current_date PASSED
tests/test_utils.py::test_get_sub_key_by_system_property_key PASSED
tests/test_utils.py::test_update_system_data_for_item_metadata PASSED
tests/test_utils.py::test_update_approval_date_for_deposit PASSED
tests/test_utils.py::test_update_system_data_for_activity FAILED
tests/test_utils.py::test_get_record_first_version PASSED
tests/test_utils.py::test_get_index_id FAILED
tests/test_utils.py::test_make_activitylog_tsv FAILED
tests/test_views.py::test_index_acl_nologin FAILED
tests/test_views.py::test_index_acl[0-200] PASSED
tests/test_views.py::test_index_acl[1-200] PASSED
tests/test_views.py::test_index_acl[2-200] PASSED
tests/test_views.py::test_index_acl[3-200] PASSED
tests/test_views.py::test_index_acl[4-200] PASSED
tests/test_views.py::test_index_acl[5-200] PASSED
tests/test_views.py::test_index_acl[6-200] PASSED
tests/test_views.py::test_iframe_success FAILED
tests/test_views.py::test_init_activity_acl_nologin FAILED
tests/test_views.py::test_init_activity_acl[0-200] PASSED
tests/test_views.py::test_init_activity_acl[1-200] PASSED
tests/test_views.py::test_init_activity_acl[2-200] PASSED
tests/test_views.py::test_init_activity_acl[3-200] PASSED
tests/test_views.py::test_init_activity_acl[4-200] PASSED
tests/test_views.py::test_init_activity_acl[5-200] PASSED
tests/test_views.py::test_init_activity_acl[6-200] PASSED
tests/test_views.py::test_init_activity[0-200] FAILED
tests/test_views.py::test_init_activity[1-200] FAILED
tests/test_views.py::test_init_activity[2-200] FAILED
tests/test_views.py::test_init_activity[3-200] FAILED
tests/test_views.py::test_init_activity[4-200] FAILED
tests/test_views.py::test_init_activity[5-200] FAILED
tests/test_views.py::test_init_activity[6-200] FAILED
tests/test_views.py::test_init_activity_guest_nologin PASSED
tests/test_views.py::test_init_activity_guest_users[0-200] PASSED
tests/test_views.py::test_init_activity_guest_users[1-200] PASSED
tests/test_views.py::test_init_activity_guest_users[2-200] PASSED
tests/test_views.py::test_init_activity_guest_users[3-200] PASSED
tests/test_views.py::test_init_activity_guest_users[4-200] PASSED
tests/test_views.py::test_init_activity_guest_users[5-200] PASSED
tests/test_views.py::test_init_activity_guest_users[6-200] PASSED
tests/test_views.py::test_find_doi_nologin PASSED
tests/test_views.py::test_find_doi_users[0-200] PASSED
tests/test_views.py::test_find_doi_users[1-200] PASSED
tests/test_views.py::test_find_doi_users[2-200] PASSED
tests/test_views.py::test_find_doi_users[3-200] PASSED
tests/test_views.py::test_find_doi_users[4-200] PASSED
tests/test_views.py::test_find_doi_users[5-200] PASSED
tests/test_views.py::test_find_doi_users[6-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[0-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[1-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[2-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[3-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[4-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[5-200] PASSED
tests/test_views.py::test_save_feedback_maillist_users[6-200] PASSED
tests/test_views.py::test_previous_action_acl_nologin FAILED
tests/test_views.py::test_previous_action_acl_users[0-403-False] PASSED
tests/test_views.py::test_previous_action_acl_users[1-403-True] PASSED
tests/test_views.py::test_previous_action_acl_users[2-403-True] PASSED
tests/test_views.py::test_previous_action_acl_users[3-403-True] PASSED
tests/test_views.py::test_previous_action_acl_users[4-403-False] PASSED
tests/test_views.py::test_previous_action_acl_users[5-403-False] PASSED
tests/test_views.py::test_previous_action_acl_users[6-403-True] PASSED
tests/test_views.py::test_previous_action[0-200] FAILED
tests/test_views.py::test_previous_action[1-200] PASSED
tests/test_views.py::test_previous_action[2-200] PASSED
tests/test_views.py::test_previous_action[3-200] FAILED
tests/test_views.py::test_previous_action[4-200] FAILED
tests/test_views.py::test_previous_action[5-200] FAILED
tests/test_views.py::test_previous_action[6-200] PASSED
tests/test_views.py::test_next_action_acl_nologin FAILED
tests/test_views.py::test_next_action_acl_users[0-403-False] PASSED
tests/test_views.py::test_next_action_acl_users[1-403-True] PASSED
tests/test_views.py::test_next_action_acl_users[2-403-True] PASSED
tests/test_views.py::test_next_action_acl_users[3-403-True] PASSED
tests/test_views.py::test_next_action_acl_users[4-403-False] PASSED
tests/test_views.py::test_next_action_acl_users[5-403-False] PASSED
tests/test_views.py::test_next_action_acl_users[6-403-True] PASSED
tests/test_views.py::test_next_action_acl_guestlogin PASSED
tests/test_views.py::test_next_action[0-200] FAILED
tests/test_views.py::test_next_action[1-200] FAILED
tests/test_views.py::test_next_action[2-200] FAILED
tests/test_views.py::test_next_action[3-200] FAILED
tests/test_views.py::test_next_action[4-200] FAILED
tests/test_views.py::test_next_action[5-200] FAILED
tests/test_views.py::test_next_action[6-200] FAILED
tests/test_views.py::test_cancel_action_acl_nologin FAILED
tests/test_views.py::test_cancel_action_acl_users[0-403-False] PASSED
tests/test_views.py::test_cancel_action_acl_users[1-403-True] PASSED
tests/test_views.py::test_cancel_action_acl_users[2-403-True] PASSED
tests/test_views.py::test_cancel_action_acl_users[3-403-True] PASSED
tests/test_views.py::test_cancel_action_acl_users[4-403-False] PASSED
tests/test_views.py::test_cancel_action_acl_users[5-403-False] PASSED
tests/test_views.py::test_cancel_action_acl_users[6-403-True] PASSED
tests/test_views.py::test_cancel_action_acl_guestlogin PASSED
tests/test_views.py::test_cancel_action[0-200] FAILED
tests/test_views.py::test_cancel_action[1-200] PASSED
tests/test_views.py::test_cancel_action[2-200] PASSED
tests/test_views.py::test_cancel_action[3-200] FAILED
tests/test_views.py::test_cancel_action[4-200] FAILED
tests/test_views.py::test_cancel_action[5-200] FAILED
tests/test_views.py::test_cancel_action[6-200] PASSED
tests/test_views.py::test_cancel_action_guest PASSED
tests/test_views.py::test_send_mail_nologin PASSED
tests/test_views.py::test_send_mail_users[0-200] PASSED
tests/test_views.py::test_send_mail_users[1-200] PASSED
tests/test_views.py::test_send_mail_users[2-200] PASSED
tests/test_views.py::test_send_mail_users[3-200] PASSED
tests/test_views.py::test_send_mail_users[4-200] PASSED
tests/test_views.py::test_send_mail_users[5-200] PASSED
tests/test_views.py::test_send_mail_users[6-200] PASSED
tests/test_views.py::test_user_lock_activity_nologin FAILED
tests/test_views.py::test_user_lock_activity_acl[0] FAILED
tests/test_views.py::test_user_lock_activity_acl[1] FAILED
tests/test_views.py::test_user_lock_activity_acl[2] FAILED
tests/test_views.py::test_user_lock_activity_acl[3] FAILED
tests/test_views.py::test_user_lock_activity_acl[4] FAILED
tests/test_views.py::test_user_lock_activity_acl[5] FAILED
tests/test_views.py::test_user_lock_activity_acl[6] FAILED
tests/test_views.py::test_user_lock_activity FAILED
tests/test_views.py::test_user_unlock_activity_nologin FAILED
tests/test_views.py::test_user_unlock_activity_acl[0] FAILED
tests/test_views.py::test_user_unlock_activity_acl[1] FAILED
tests/test_views.py::test_user_unlock_activity_acl[2] FAILED
tests/test_views.py::test_user_unlock_activity_acl[3] FAILED
tests/test_views.py::test_user_unlock_activity_acl[4] FAILED
tests/test_views.py::test_user_unlock_activity_acl[5] FAILED
tests/test_views.py::test_user_unlock_activity_acl[6] FAILED
tests/test_views.py::test_user_unlock_activity FAILED
tests/test_views.py::test_lock_activity_nologin PASSED
tests/test_views.py::test_lock_activity_users[0-200] PASSED
tests/test_views.py::test_lock_activity_users[1-200] PASSED
tests/test_views.py::test_lock_activity_users[2-200] PASSED
tests/test_views.py::test_lock_activity_users[3-200] PASSED
tests/test_views.py::test_lock_activity_users[4-200] PASSED
tests/test_views.py::test_lock_activity_users[5-200] PASSED
tests/test_views.py::test_lock_activity_users[6-200] PASSED
tests/test_views.py::test_lock_activity FAILED
tests/test_views.py::test_unlock_activity_acl_nologin FAILED
tests/test_views.py::test_unlock_activity_acl_users[0-200] PASSED
tests/test_views.py::test_unlock_activity_acl_users[1-200] PASSED
tests/test_views.py::test_unlock_activity_acl_users[2-200] PASSED
tests/test_views.py::test_unlock_activity_acl_users[3-200] PASSED
tests/test_views.py::test_unlock_activity_acl_users[4-200] PASSED
tests/test_views.py::test_unlock_activity_acl_users[5-200] PASSED
tests/test_views.py::test_unlock_activity_acl_users[6-200] PASSED
tests/test_views.py::test_unlock_activity[0-200] FAILED
tests/test_views.py::test_unlock_activity[1-200] FAILED
tests/test_views.py::test_unlock_activity[2-200] FAILED
tests/test_views.py::test_unlock_activity[3-200] FAILED
tests/test_views.py::test_unlock_activity[4-200] FAILED
tests/test_views.py::test_unlock_activity[5-200] FAILED
tests/test_views.py::test_unlock_activity[6-200] FAILED
tests/test_views.py::test_check_approval_acl_nologin FAILED
tests/test_views.py::test_check_approval_acl_users[0-200] PASSED
tests/test_views.py::test_check_approval_acl_users[1-200] PASSED
tests/test_views.py::test_check_approval_acl_users[2-200] PASSED
tests/test_views.py::test_check_approval_acl_users[3-200] PASSED
tests/test_views.py::test_check_approval_acl_users[4-200] PASSED
tests/test_views.py::test_check_approval_acl_users[5-200] PASSED
tests/test_views.py::test_check_approval_acl_users[6-200] PASSED
tests/test_views.py::test_check_approval[0-200] PASSED
tests/test_views.py::test_check_approval[1-200] PASSED
tests/test_views.py::test_check_approval[2-200] PASSED
tests/test_views.py::test_check_approval[3-200] PASSED
tests/test_views.py::test_check_approval[4-200] PASSED
tests/test_views.py::test_check_approval[5-200] PASSED
tests/test_views.py::test_check_approval[6-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_nologin FAILED
tests/test_views.py::test_get_feedback_maillist_acl_users[0-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_users[1-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_users[2-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_users[3-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_users[4-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_users[5-200] PASSED
tests/test_views.py::test_get_feedback_maillist_acl_users[6-200] PASSED
tests/test_views.py::test_get_feedback_maillist[0-200] FAILED
tests/test_views.py::test_get_feedback_maillist[1-200] FAILED
tests/test_views.py::test_get_feedback_maillist[2-200] FAILED
tests/test_views.py::test_get_feedback_maillist[3-200] FAILED
tests/test_views.py::test_get_feedback_maillist[4-200] FAILED
tests/test_views.py::test_get_feedback_maillist[5-200] FAILED
tests/test_views.py::test_get_feedback_maillist[6-200] FAILED
tests/test_views.py::test_save_activity_acl_nologin FAILED
tests/test_views.py::test_save_activity_acl_users[0-200] PASSED
tests/test_views.py::test_save_activity_acl_users[1-200] PASSED
tests/test_views.py::test_save_activity_acl_users[2-200] PASSED
tests/test_views.py::test_save_activity_acl_users[3-200] PASSED
tests/test_views.py::test_save_activity_acl_users[4-200] PASSED
tests/test_views.py::test_save_activity_acl_users[5-200] PASSED
tests/test_views.py::test_save_activity_acl_users[6-200] PASSED
tests/test_views.py::test_save_activity_acl_guestlogin PASSED
tests/test_views.py::test_save_activity[0-200] PASSED
tests/test_views.py::test_save_activity[1-200] PASSED
tests/test_views.py::test_save_activity[2-200] PASSED
tests/test_views.py::test_save_activity[3-200] PASSED
tests/test_views.py::test_save_activity[4-200] PASSED
tests/test_views.py::test_save_activity[5-200] PASSED
tests/test_views.py::test_save_activity[6-200] PASSED
tests/test_views.py::test_save_activity_guestlogin PASSED
tests/test_views.py::test_display_activity_nologin PASSED
tests/test_views.py::test_display_activity_users[0-200] PASSED
tests/test_views.py::test_display_activity_users[1-200] PASSED
tests/test_views.py::test_display_activity_users[2-200] PASSED
tests/test_views.py::test_display_activity_users[3-200] PASSED
tests/test_views.py::test_display_activity_users[4-200] PASSED
tests/test_views.py::test_display_activity_users[5-200] PASSED
tests/test_views.py::test_display_activity_users[6-200] PASSED
tests/test_views.py::test_display_activity FAILED
tests/test_views.py::test_withdraw_confirm_nologin FAILED
tests/test_views.py::test_withdraw_confirm_users[0-403-False] PASSED
tests/test_views.py::test_withdraw_confirm_users[1-403-True] PASSED
tests/test_views.py::test_withdraw_confirm_users[2-403-True] PASSED
tests/test_views.py::test_withdraw_confirm_users[3-403-True] PASSED
tests/test_views.py::test_withdraw_confirm_users[4-403-False] PASSED
tests/test_views.py::test_withdraw_confirm_users[5-403-False] PASSED
tests/test_views.py::test_withdraw_confirm_users[6-403-True] PASSED
tests/test_views.py::test_withdraw_confirm_guestlogin PASSED
tests/test_views.py::test_withdraw_confirm_exception1[0] PASSED
tests/test_views.py::test_withdraw_confirm_exception1[1] PASSED
tests/test_views.py::test_withdraw_confirm_exception1[2] PASSED
tests/test_views.py::test_withdraw_confirm_exception1[3] PASSED
tests/test_views.py::test_withdraw_confirm_exception1[4] PASSED
tests/test_views.py::test_withdraw_confirm_exception1[5] PASSED
tests/test_views.py::test_withdraw_confirm_exception1[6] PASSED
tests/test_views.py::test_withdraw_confirm_exception1_guestlogin PASSED
tests/test_views.py::test_withdraw_confirm_exception2[0-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[0-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[0-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[0-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[1-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[1-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[1-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[1-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[2-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[2-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[2-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[2-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[3-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[3-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[3-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[3-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[4-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[4-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[4-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[4-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[5-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[5-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[5-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[5-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[6-input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[6-input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2[6-input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2[6-input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_exception2_guestlogin[input_data0-500--1-{'passwd': ['Missing data for required field.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2_guestlogin[input_data1-500--1-{'passwd': ['Field may not be null.']}] PASSED
tests/test_views.py::test_withdraw_confirm_exception2_guestlogin[input_data2-500--1-bad identifier data] FAILED
tests/test_views.py::test_withdraw_confirm_exception2_guestlogin[input_data3-500--1-Invalid password] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[0-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[1-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[2-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[3-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[4-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[5-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete[6-success-200-0-success] PASSED
tests/test_views.py::test_withdraw_confirm_passwd_delete_guestlogin[success-200-0-success] PASSED
tests/test_views.py::test_download_activitylog_nologin PASSED
tests/test_views.py::test_download_activitylog_1[0-403] PASSED
tests/test_views.py::test_download_activitylog_1[1-200] FAILED
tests/test_views.py::test_download_activitylog_1[2-200] FAILED
tests/test_views.py::test_download_activitylog_1[3-403] PASSED
tests/test_views.py::test_download_activitylog_1[4-403] PASSED
tests/test_views.py::test_download_activitylog_1[5-403] PASSED
tests/test_views.py::test_download_activitylog_1[6-200] FAILED
tests/test_views.py::test_download_activitylog_2[1-200] FAILED
tests/test_views.py::test_download_activitylog_2[2-200] FAILED
tests/test_views.py::test_download_activitylog_2[6-200] FAILED
tests/test_views.py::test_clear_activitylog_nologin PASSED
tests/test_views.py::test_clear_activitylog_1[0-403] PASSED
tests/test_views.py::test_clear_activitylog_1[1-200] PASSED
tests/test_views.py::test_clear_activitylog_1[2-200] PASSED
tests/test_views.py::test_clear_activitylog_1[3-403] PASSED
tests/test_views.py::test_clear_activitylog_1[4-403] PASSED
tests/test_views.py::test_clear_activitylog_1[5-403] PASSED
tests/test_views.py::test_clear_activitylog_1[6-200] PASSED
tests/test_views.py::test_clear_activitylog_2[1-200] PASSED
tests/test_views.py::test_clear_activitylog_2[2-200] PASSED
tests/test_views.py::test_clear_activitylog_2[6-200] PASSED
tests/test_views.py::test_clear_activitylog_3[1-200] PASSED
tests/test_views.py::test_clear_activitylog_3[2-200] PASSED
tests/test_views.py::test_clear_activitylog_3[6-200] PASSED
tests/test_views.py::test_clear_activitylog_4[1-200] PASSED
tests/test_views.py::test_clear_activitylog_4[2-200] PASSED
tests/test_views.py::test_clear_activitylog_4[6-200] PASSED
tests/test_views.py::test_clear_activitylog_5[0-403] PASSED
tests/test_views.py::test_clear_activitylog_5[1-200] PASSED
tests/test_views.py::test_clear_activitylog_5[2-200] PASSED
tests/test_views.py::test_clear_activitylog_5[3-403] PASSED
tests/test_views.py::test_clear_activitylog_5[4-403] PASSED
tests/test_views.py::test_clear_activitylog_5[5-403] PASSED
tests/test_views.py::test_clear_activitylog_5[6-200] PASSED
tests/test_views.py::test_clear_activitylog_6[1-200] PASSED
tests/test_views.py::test_clear_activitylog_6[2-200] PASSED
tests/test_views.py::test_clear_activitylog_6[6-200] PASSED
tests/test_views.py::test_clear_activitylog_7[1-200] PASSED
tests/test_views.py::test_clear_activitylog_7[2-200] PASSED
tests/test_views.py::test_clear_activitylog_7[6-200] PASSED
tests/test_views.py::test_clear_activitylog_8[1-200] PASSED
tests/test_views.py::test_clear_activitylog_8[2-200] PASSED
tests/test_views.py::test_clear_activitylog_8[6-200] PASSED
tests/test_views.py::test_clear_activitylog_9[0-403] PASSED
tests/test_views.py::test_clear_activitylog_9[1-200] PASSED
tests/test_views.py::test_clear_activitylog_9[2-200] PASSED
tests/test_views.py::test_clear_activitylog_9[3-403] PASSED
tests/test_views.py::test_clear_activitylog_9[4-403] PASSED
tests/test_views.py::test_clear_activitylog_9[5-403] PASSED
tests/test_views.py::test_clear_activitylog_9[6-200] PASSED

==================================== ERRORS ====================================
________ ERROR at setup of test_cancel_expired_usage_report_activities _________

self = <sqlalchemy.engine.base.Connection object at 0x7fa9b642c908>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b5d23940>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2'>>
statement = 'INSERT INTO guest_activity (created, updated, user_mail, record_id, file_name, activity_id, token, expiration_date, i...id)s, %(file_name)s, %(activity_id)s, %(token)s, %(expiration_date)s, %(is_usage_report)s) RETURNING guest_activity.id'
parameters = {'activity_id': 'activity_id', 'created': datetime.datetime(2023, 10, 9, 17, 18, 59, 790891), 'expiration_date': datetime.datetime(2023, 10, 9, 17, 18, 59, 781676), 'file_name': 'file_name', ...}
args = (<sqlalchemy.dialects.postgresql.psycopg2.PGCompiler_psycopg2 object at 0x7fa9b642ceb8>, [{'activity_id': 'activity_id...n_date': datetime.datetime(2023, 10, 9, 17, 18, 59, 781676), 'file_name': 'file_name', 'is_usage_report': False, ...}])
conn = <sqlalchemy.pool._ConnectionFairy object at 0x7fa9b63c3780>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9b642cef0>

    def _execute_context(
        self, dialect, constructor, statement, parameters, *args
    ):
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`.ResultProxy`."""
    
        try:
            try:
                conn = self.__connection
            except AttributeError:
                # escape "except AttributeError" before revalidating
                # to prevent misleading stacktraces in Py3K
                conn = None
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(dialect, self, conn, *args)
        except BaseException as e:
            self._handle_dbapi_exception(
                e, util.text_type(statement), parameters, None, None
            )
    
        if context.compiled:
            context.pre_exec()
    
        cursor, statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        if not context.executemany:
            parameters = parameters[0]
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                statement, parameters = fn(
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self.engine.logger.info(statement)
            self.engine.logger.info(
                "%r", sql_util._repr_params(parameters, batches=10)
            )
    
        evt_handled = False
        try:
            if context.executemany:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor, statement, parameters, context
                    )
            elif not parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, statement, context
                    )
            else:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
>                       cursor, statement, parameters, context
                    )

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b5d23940>
cursor = <cursor object at 0x7fa9bc7feed0; closed: -1>
statement = 'INSERT INTO guest_activity (created, updated, user_mail, record_id, file_name, activity_id, token, expiration_date, i...id)s, %(file_name)s, %(activity_id)s, %(token)s, %(expiration_date)s, %(is_usage_report)s) RETURNING guest_activity.id'
parameters = {'activity_id': 'activity_id', 'created': datetime.datetime(2023, 10, 9, 17, 18, 59, 790891), 'expiration_date': datetime.datetime(2023, 10, 9, 17, 18, 59, 781676), 'file_name': 'file_name', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9b642cef0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.ProgrammingError: column "expiration_date" is of type integer but expression is of type timestamp without time zone
E       LINE 1: ...'record_id', 'file_name', 'activity_id', 'token', '2023-10-0...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: ProgrammingError

The above exception was the direct cause of the following exception:

db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>

    @pytest.fixture()
    def db_guestactivity(db):
        record = GuestActivity(user_mail="user_mail",record_id="record_id",file_name="file_name",activity_id="activity_id",token="token",expiration_date=datetime.utcnow(),is_usage_report=False)
        with db.session.begin_nested():
>           db.session.add(record)

tests/conftest.py:1563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:597: in __exit__
    self.rollback()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:67: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:277: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:594: in __exit__
    self.commit()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:487: in commit
    self._prepare_impl()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:466: in _prepare_impl
    self.session.flush()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:2446: in flush
    self._flush(objects)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:2584: in _flush
    transaction.rollback(_capture_exception=True)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:67: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:277: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:2544: in _flush
    flush_context.execute()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/unitofwork.py:416: in execute
    rec.execute(self)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/unitofwork.py:583: in execute
    uow,
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/persistence.py:245: in save_obj
    insert,
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/persistence.py:1116: in _emit_insert_statements
    statement, params
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:980: in execute
    return meth(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/sql/elements.py:273: in _execute_on_connection
    return connection._execute_clauseelement(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1099: in _execute_clauseelement
    distilled_params,
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1240: in _execute_context
    e, statement, parameters, cursor, context
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1458: in _handle_dbapi_exception
    util.raise_from_cause(sqlalchemy_exception, exc_info)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:296: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:276: in reraise
    raise value.with_traceback(tb)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: in _execute_context
    cursor, statement, parameters, context
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b5d23940>
cursor = <cursor object at 0x7fa9bc7feed0; closed: -1>
statement = 'INSERT INTO guest_activity (created, updated, user_mail, record_id, file_name, activity_id, token, expiration_date, i...id)s, %(file_name)s, %(activity_id)s, %(token)s, %(expiration_date)s, %(is_usage_report)s) RETURNING guest_activity.id'
parameters = {'activity_id': 'activity_id', 'created': datetime.datetime(2023, 10, 9, 17, 18, 59, 790891), 'expiration_date': datetime.datetime(2023, 10, 9, 17, 18, 59, 781676), 'file_name': 'file_name', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9b642cef0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.ProgrammingError) column "expiration_date" is of type integer but expression is of type timestamp without time zone
E       LINE 1: ...'record_id', 'file_name', 'activity_id', 'token', '2023-10-0...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E        [SQL: 'INSERT INTO guest_activity (created, updated, user_mail, record_id, file_name, activity_id, token, expiration_date, is_usage_report) VALUES (%(created)s, %(updated)s, %(user_mail)s, %(record_id)s, %(file_name)s, %(activity_id)s, %(token)s, %(expiration_date)s, %(is_usage_report)s) RETURNING guest_activity.id'] [parameters: {'created': datetime.datetime(2023, 10, 9, 17, 18, 59, 790891), 'updated': datetime.datetime(2023, 10, 9, 17, 18, 59, 790904), 'user_mail': 'user_mail', 'record_id': 'record_id', 'file_name': 'file_name', 'activity_id': 'activity_id', 'token': 'token', 'expiration_date': datetime.datetime(2023, 10, 9, 17, 18, 59, 781676), 'is_usage_report': False}] (Background on this error at: http://sqlalche.me/e/f405)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: ProgrammingError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
=================================== FAILURES ===================================
_______________ TestFlowSettingView.test_flow_detail_acl[1-200] ________________

self = <tests.test_admin.TestFlowSettingView object at 0x7fa9bdfb3518>
client = <FlaskClient <Flask 'testapp'>>
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}
db_register2 = None
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 1, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        # (0, 403),
        (1, 200),
        # (2, 200),
        # (3, 200),
        # (4, 200),
        # (5, 200),
        # (6, 200),
    ])
    def test_flow_detail_acl(self,client,workflow,db_register2,users,users_index,status_code):
        flow_define = workflow['flow']
        login(client=client, email=users[users_index]['email'])
        url = '/admin/workflowsetting/{}'.format(0)
        with patch("flask.templating._render", return_value=""):
            res =  client.get(url)
            assert res.status_code == status_code
    
    
        url = '/admin/workflowsetting/{}'.format(flow_define.flow_id)
        with patch("flask.templating._render", return_value=""):
>           res =  client.get(url)

tests/test_admin.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:69: in inner
    return self._run_view(f, *args, **kwargs)
.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:368: in _run_view
    return fn(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <invenio_admin.views.protected_adminview_factory.<locals>.ProtectedAdminView object at 0x7fa9be77bb38>
workflow_id = '0e3f9fc9-5103-4651-983d-91a72ba1cd03'

    @expose('/<string:workflow_id>', methods=['GET'])
    def workflow_detail(self, workflow_id='0'):
        """Get workflow info.
    
        :return:
        """
        if WEKO_WORKFLOW_SHOW_HARVESTING_ITEMS:
            itemtype_list = ItemTypes.get_latest()
        else:
            itemtype_list = ItemTypes.get_latest_custorm_harvesting()
        flow_api = Flow()
        flow_list = flow_api.get_flow_list()
        index_list = Index().get_all()
        location_list = Location.query.order_by(Location.id.asc()).all()
        hide = []
        role = Role.query.all()
        display_label = self.get_language_workflows("display")
        hide_label = self.get_language_workflows("hide")
        display_hide = self.get_language_workflows("display_hide")
    
        if '0' == workflow_id:
            """Create new workflow"""
            return self.render(
                'weko_workflow/admin/workflow_detail.html',
                workflow=None,
                itemtype_list=itemtype_list,
                flow_list=flow_list,
                index_list=index_list,
                location_list=location_list,
                hide_list=hide,
                display_list=role,
                display_label=display_label,
                hide_label=hide_label,
                display_hide_label=display_hide,
            )
    
        """Update the workflow info"""
        workflow = WorkFlow()
        workflows = workflow.get_workflow_detail(workflow_id)
        hide = Role.query.outerjoin(WorkflowRole) \
>           .filter(WorkflowRole.workflow_id == workflows.id) \
            .filter(WorkflowRole.role_id == Role.id) \
            .all()
E       AttributeError: 'NoneType' object has no attribute 'id'

weko_workflow/admin.py:294: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_____________________ TestFlowSettingView.test_update_flow _____________________

self = <tests.test_admin.TestFlowSettingView object at 0x7fa9bd60f0b8>
app = <Flask 'testapp'>
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}

    def test_update_flow(self,app,workflow):
        with app.test_request_context():
>           assert FlowSettingView.update_flow(0)==""

tests/test_admin.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
weko_workflow/admin.py:122: in update_flow
    workflow.upt_flow(flow_id, post_data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <weko_workflow.api.Flow object at 0x7fa9bcaac710>, flow_id = 0
flow = None

    def upt_flow(self, flow_id, flow):
        """Update flow info.
    
        :param flow_id:
        :param flow:
        :return:
        """
        try:
>           flow_name = flow.get('flow_name')
E           AttributeError: 'NoneType' object has no attribute 'get'

weko_workflow/api.py:119: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:api.py:142 'NoneType' object has no attribute 'get'
Traceback (most recent call last):
  File "/code/modules/weko-workflow/weko_workflow/api.py", line 119, in upt_flow
    flow_name = flow.get('flow_name')
AttributeError: 'NoneType' object has no attribute 'get'
______________________ TestFlowSettingView.test_new_flow _______________________

self = <tests.test_admin.TestFlowSettingView object at 0x7fa9bc8af278>
app = <Flask 'testapp'>
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}

    def test_new_flow(self,app,workflow):
        with app.test_request_context():
>           assert FlowSettingView.new_flow(0)==""

tests/test_admin.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, args = (), kwargs = {}

    @wraps(f)
    def inner(self, *args, **kwargs):
        # Store current admin view
        h.set_current_view(self)
    
        # Check if administrative piece is accessible
>       abort = self._handle_view(f.__name__, **kwargs)
E       AttributeError: 'int' object has no attribute '_handle_view'

.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:65: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ TestFlowSettingView.test_del_flow _______________________

self = <tests.test_admin.TestFlowSettingView object at 0x7fa9bc1c3e80>
app = <Flask 'testapp'>
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}

    def test_del_flow(self,app,workflow):
        with app.test_request_context():
>           assert FlowSettingView.del_flow(0)==""

tests/test_admin.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, args = (), kwargs = {}

    @wraps(f)
    def inner(self, *args, **kwargs):
        # Store current admin view
        h.set_current_view(self)
    
        # Check if administrative piece is accessible
>       abort = self._handle_view(f.__name__, **kwargs)
E       AttributeError: 'int' object has no attribute '_handle_view'

.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:65: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_____________________ TestFlowSettingView.test_get_actions _____________________

self = <tests.test_admin.TestFlowSettingView object at 0x7fa9bd013668>
app = <Flask 'testapp'>
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}

    def test_get_actions(self,app,workflow):
        with app.test_request_context():
>           assert FlowSettingView.get_actions()==""
E           AssertionError: assert [<Action 1>, <Action 2>, <Action 3>, <Action 4>, <Action 5>, <Action 7>] == ''
E             +[<Action 1>, <Action 2>, <Action 3>, <Action 4>, <Action 5>, <Action 7>]
E             -''

tests/test_admin.py:96: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
___________________ TestFlowSettingView.test_upt_flow_action ___________________

self = <tests.test_admin.TestFlowSettingView object at 0x7fa9bbd54320>
app = <Flask 'testapp'>
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}

    def test_upt_flow_action(self,app,workflow):
        with app.test_request_context():
>           assert FlowSettingView.upt_flow_action(0)==""

tests/test_admin.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 0, args = (), kwargs = {}

    @wraps(f)
    def inner(self, *args, **kwargs):
        # Store current admin view
        h.set_current_view(self)
    
        # Check if administrative piece is accessible
>       abort = self._handle_view(f.__name__, **kwargs)
E       AttributeError: 'int' object has no attribute '_handle_view'

.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:65: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
___________ TestWorkFlowSettingView.test_update_workflow_acl[1-200] ____________

self = <tests.test_admin.TestWorkFlowSettingView object at 0x7fa9bb6c4e80>
client = <FlaskClient <Flask 'testapp'>>, db_register2 = None
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 1, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        # (0, 403),
        (1, 200),
        # (2, 200),
        # (3, 200),
        # (4, 200),
        # (5, 200),
        # (6, 200),
    ])
    def test_update_workflow_acl(self,client,db_register2,users,users_index,status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('workflowsetting.update_workflow',workflow_id='0',_external=True)
        with patch("flask.templating._render", return_value=""):
>           res =  client.post(url)

tests/test_admin.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:69: in inner
    return self._run_view(f, *args, **kwargs)
.tox/c1/lib/python3.6/site-packages/flask_admin/base.py:368: in _run_view
    return fn(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <invenio_admin.views.protected_adminview_factory.<locals>.ProtectedAdminView object at 0x7fa9bb9adf60>
workflow_id = '0'

    @expose('/<string:workflow_id>', methods=['POST', 'PUT'])
    def update_workflow(self, workflow_id='0'):
        """Update workflow info.
    
        :return:
        """
        json_data = request.get_json()
>       list_hide = json_data.get('list_hide', [])
E       AttributeError: 'NoneType' object has no attribute 'get'

weko_workflow/admin.py:324: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________ TestWorkFlowSettingView.test_save_workflow_role ________________

self = <tests.test_admin.TestWorkFlowSettingView object at 0x7fa9b94b2dd8>
app = <Flask 'testapp'>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}

    def test_save_workflow_role(self,app,users,workflow):
        role0 = (users[0]['obj']).roles[0]
        role1 = (users[1]['obj']).roles[0]
        role2 = (users[2]['obj']).roles[0]
        role3 = (users[3]['obj']).roles[0]
        role4 = (users[4]['obj']).roles[0]
    
        wf = workflow['workflow']
    
        with app.test_request_context():
>           assert WorkFlowSettingView.save_workflow_role(wf.id,[role0.id,role1.id,role2.id,role3.id,role4.id])
E           AssertionError: assert None
E            +  where None = <bound method WorkFlowSettingView.save_workflow_role of <class 'weko_workflow.admin.WorkFlowSettingView'>>(1, [])
E            +    where <bound method WorkFlowSettingView.save_workflow_role of <class 'weko_workflow.admin.WorkFlowSettingView'>> = WorkFlowSettingView.save_workflow_role
E            +    and   1 = <WorkFlow 1>.id

tests/test_admin.py:248: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:admin.py:433 wf_id:1
ERROR    testapp:admin.py:435 list_hide:[3, 2, 1, 4, 5]
_____________ TestWorkFlowSettingView.test_get_language_workflows ______________

self = <tests.test_admin.TestWorkFlowSettingView object at 0x7fa9b8cbd198>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]

    def test_get_language_workflows(self,users):
>       with self.test_request_context():
E       AttributeError: 'TestWorkFlowSettingView' object has no attribute 'test_request_context'

tests/test_admin.py:253: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_________________ test_WorkActivity_get_activity_index_search __________________

self = <sqlalchemy.engine.base.Connection object at 0x7fa9bb5242e8>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b7cfe710>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2'>>
statement = 'SELECT workflow_activity.status AS workflow_activity_status, workflow_activity.created AS workflow_activity_created, ...r AS workflow_activity_action_order \nFROM workflow_activity \nWHERE workflow_activity.activity_id = %(activity_id_1)s'
parameters = {'activity_id_1': 1}
args = (<sqlalchemy.dialects.postgresql.psycopg2.PGCompiler_psycopg2 object at 0x7fa9bb524080>, [immutabledict({})])
conn = <sqlalchemy.pool._ConnectionFairy object at 0x7fa9bb524f60>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9bb5240f0>

    def _execute_context(
        self, dialect, constructor, statement, parameters, *args
    ):
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`.ResultProxy`."""
    
        try:
            try:
                conn = self.__connection
            except AttributeError:
                # escape "except AttributeError" before revalidating
                # to prevent misleading stacktraces in Py3K
                conn = None
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(dialect, self, conn, *args)
        except BaseException as e:
            self._handle_dbapi_exception(
                e, util.text_type(statement), parameters, None, None
            )
    
        if context.compiled:
            context.pre_exec()
    
        cursor, statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        if not context.executemany:
            parameters = parameters[0]
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                statement, parameters = fn(
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self.engine.logger.info(statement)
            self.engine.logger.info(
                "%r", sql_util._repr_params(parameters, batches=10)
            )
    
        evt_handled = False
        try:
            if context.executemany:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor, statement, parameters, context
                    )
            elif not parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, statement, context
                    )
            else:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
>                       cursor, statement, parameters, context
                    )

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b7cfe710>
cursor = <cursor object at 0x7fa9bc7feaf0; closed: -1>
statement = 'SELECT workflow_activity.status AS workflow_activity_status, workflow_activity.created AS workflow_activity_created, ...r AS workflow_activity_action_order \nFROM workflow_activity \nWHERE workflow_activity.activity_id = %(activity_id_1)s'
parameters = {'activity_id_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9bb5240f0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.ProgrammingError: operator does not exist: character varying = integer
E       LINE 3: WHERE workflow_activity.activity_id = 1
E                                                   ^
E       HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: ProgrammingError

The above exception was the direct cause of the following exception:

app = <Flask 'testapp'>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    def test_WorkActivity_get_activity_index_search(app, db_register):
        activity = WorkActivity()
        with app.test_request_context():
            activity_detail, item, steps, action_id, cur_step, \
                temporary_comment, approval_record, step_item_login_url,\
>               histories, res_check, pid, community_id, ctx = activity.get_activity_index_search(1)

tests/test_api.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
weko_workflow/api.py:2053: in get_activity_index_search
    activity_detail = activity.get_activity_detail(activity_id)
weko_workflow/api.py:1993: in get_activity_detail
    activity = self.get_activity_by_id(activity_id)
weko_workflow/api.py:2242: in get_activity_by_id
    return _Activity.query.filter_by(activity_id=activity_id).one_or_none()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:3008: in one_or_none
    ret = list(self)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:3081: in __iter__
    return self._execute_and_instances(context)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:3106: in _execute_and_instances
    result = conn.execute(querycontext.statement, self._params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:980: in execute
    return meth(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/sql/elements.py:273: in _execute_on_connection
    return connection._execute_clauseelement(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1099: in _execute_clauseelement
    distilled_params,
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1240: in _execute_context
    e, statement, parameters, cursor, context
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1458: in _handle_dbapi_exception
    util.raise_from_cause(sqlalchemy_exception, exc_info)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:296: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:276: in reraise
    raise value.with_traceback(tb)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: in _execute_context
    cursor, statement, parameters, context
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b7cfe710>
cursor = <cursor object at 0x7fa9bc7feaf0; closed: -1>
statement = 'SELECT workflow_activity.status AS workflow_activity_status, workflow_activity.created AS workflow_activity_created, ...r AS workflow_activity_action_order \nFROM workflow_activity \nWHERE workflow_activity.activity_id = %(activity_id_1)s'
parameters = {'activity_id_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9bb5240f0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.ProgrammingError) operator does not exist: character varying = integer
E       LINE 3: WHERE workflow_activity.activity_id = 1
E                                                   ^
E       HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
E        [SQL: 'SELECT workflow_activity.status AS workflow_activity_status, workflow_activity.created AS workflow_activity_created, workflow_activity.updated AS workflow_activity_updated, workflow_activity.id AS workflow_activity_id, workflow_activity.activity_id AS workflow_activity_activity_id, workflow_activity.activity_name AS workflow_activity_activity_name, workflow_activity.item_id AS workflow_activity_item_id, workflow_activity.workflow_id AS workflow_activity_workflow_id, workflow_activity.workflow_status AS workflow_activity_workflow_status, workflow_activity.flow_id AS workflow_activity_flow_id, workflow_activity.action_id AS workflow_activity_action_id, workflow_activity.action_status AS workflow_activity_action_status, workflow_activity.activity_login_user AS workflow_activity_activity_login_user, workflow_activity.activity_update_user AS workflow_activity_activity_update_user, workflow_activity.activity_status AS workflow_activity_activity_status, workflow_activity.activity_start AS workflow_activity_activity_start, workflow_activity.activity_end AS workflow_activity_activity_end, workflow_activity.activity_community_id AS workflow_activity_activity_community_id, workflow_activity.activity_confirm_term_of_use AS workflow_activity_activity_confirm_term_of_use, workflow_activity.title AS workflow_activity_title, workflow_activity.shared_user_id AS workflow_activity_shared_user_id, workflow_activity.temp_data AS workflow_activity_temp_data, workflow_activity.approval1 AS workflow_activity_approval1, workflow_activity.approval2 AS workflow_activity_approval2, workflow_activity.extra_info AS workflow_activity_extra_info, workflow_activity.action_order AS workflow_activity_action_order \nFROM workflow_activity \nWHERE workflow_activity.activity_id = %(activity_id_1)s'] [parameters: {'activity_id_1': 1}] (Background on this error at: http://sqlalche.me/e/f405)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: ProgrammingError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
____________________ test_WorkActivity_upt_activity_detail _____________________

app = <Flask 'testapp'>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
db_records = [(<PersistentIdentifier recid:1 / rec:c122f884-8ee0-4176-aba4-5805aff5543e (R)>, <PersistentIdentifier depid:1 / rec:c...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:a90de498-befd-47dd-87b3-5eaf17d96269 (R)>, None, ...)]

    def test_WorkActivity_upt_activity_detail(app, db_register, db_records):
        activity = WorkActivity()
        db_activity = activity.upt_activity_detail(db_records[2][2].id)
>       assert db_activity == None
E       assert <Activity 4> == None
E         +<Activity 4>
E         -None

tests/test_api.py:111: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__________________________ test_init_workflow_tables ___________________________

app = <Flask 'testapp'>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]

    def test_init_workflow_tables(app,db,users):
        runner = app.test_cli_runner()
        result = runner.invoke(init_workflow_tables,["Action,action_status"])
        assert result.output ==  'workflow db has been initialised.\n'
        assert result.exit_code == 0
    
        result = runner.invoke(init_workflow_tables,["gakuninrdm_data"])
>       assert result.output == ""
E       assert ('(psycopg2.IntegrityError) insert or update on table "workflow_workflow" '\n 'violates foreign key constraint '\n '"fk_workflow_workflow_itemtype_id_item_type"\n'\n 'DETAIL:  Key (itemtype_id)=(15) is not present in table "item_type".\n'\n " [SQL: 'INSERT INTO workflow_workflow (status, created, updated, id, "\n 'flows_id, flows_name, itemtype_id, flow_id, is_deleted, open_restricted, '\n 'is_gakuninrdm) VALUES (%(status)s, %(created)s, %(updated)s, %(id)s, '\n '%(flows_id)s, %(flows_name)s, %(itemtype_id)s, %(flow_id)s, %(is_deleted)s, '\n "%(open_restricted)s, %(is_gakuninrdm)s)'] [parameters: {'status': 'N', "\n "'created': datetime.datetime(2023, 10, 9, 17, 18, 29, 952500), 'updated': "\n "datetime.datetime(2023, 10, 9, 17, 18, 29, 952514), 'id': -1, 'flows_id': "\n "UUID('7d2cf19d-50d2-47c3-bced-e49fe45cdc0e'), 'flows_name': "\n "'GRDM_デフォルトワークフロー', 'itemtype_id': 15, 'flow_id': -1, 'is_deleted': False, "\n "'open_restricted': False, 'is_gakuninrdm': True}] (Background on this error "\n 'at: http://sqlalche.me/e/gkpj)\n'\n 'workflow db init failed.\n') == ''
E         + (psycopg2.IntegrityError) insert or update on table "workflow_workflow" violates foreign key constraint "fk_workflow_workflow_itemtype_id_item_type"
E         + DETAIL:  Key (itemtype_id)=(15) is not present in table "item_type".
E         +  [SQL: 'INSERT INTO workflow_workflow (status, created, updated, id, flows_id, flows_name, itemtype_id, flow_id, is_deleted, open_restricted, is_gakuninrdm) VALUES (%(status)s, %(created)s, %(updated)s, %(id)s, %(flows_id)s, %(flows_name)s, %(itemtype_id)s, %(flow_id)s, %(is_deleted)s, %(open_restricted)s, %(is_gakuninrdm)s)'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 18, 29, 952500), 'updated': datetime.datetime(2023, 10, 9, 17, 18, 29, 952514), 'id': -1, 'flows_id': UUID('7d2cf19d-50d2-47c3-bced-e49fe45cdc0e'), 'flows_name': 'GRDM_デフォルトワークフロー', 'itemtype_id': 15, 'flow_id': -1, 'is_deleted': False, 'open_restricted': False, 'is_gakuninrdm': True}] (Background on this error at: http://sqlalche.me/e/gkpj)
E         + workflow db init failed.

tests/test_cli.py:27: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_validation_item_property _________________________

db_records = [(<PersistentIdentifier recid:1 / rec:5d12c139-56be-45ea-9106-6645cb003d48 (R)>, <PersistentIdentifier depid:1 / rec:5...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:69f4b019-dd17-4455-8808-33bd29955904 (R)>, None, ...)]
item_type = <ItemType 1>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa9b46574a8>

    def test_validation_item_property(db_records,item_type,mocker):
        mapping_item = MappingData(db_records[0][3].id)
        properties = {
            "required":["item1","item2"],
            "either":["item3","item4"]
        }
        not_error = {"required":[],"either":[],"pattern":[],"mapping":[]}
        with patch("weko_workflow.utils.validattion_item_property_required",return_value=None):
            with patch("weko_workflow.utils.validattion_item_property_either_required",return_value=None):
>               result = validation_item_property(mapping_item,properties,"1")
E               TypeError: validation_item_property() takes 2 positional arguments but 3 were given

tests/test_utils.py:360: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________ test_handle_check_required_pattern_and_either _________________

db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
item_type = <ItemType 1>

    def test_handle_check_required_pattern_and_either(db,item_type):
        # mapping_data is None, mapping_key is None
        result = handle_check_required_pattern_and_either(None,None,None)
        assert result == None
    
        rec_uuid1 = uuid.uuid4()
        record_data = {
            "path":["1"],"recid":"1","title":["title"],"item_title": "title","item_type_id": "1",
            "item_1617186331708": {"attribute_name": "Title","attribute_value_mlt": [{ "subitem_1551255647225": "title1"}]},
            "item_1617258105262": {"attribute_name": "Resource Type","attribute_value_mlt": [{"resourceuri": "http://purl.org/coar/resource_type/c_5794","resourcetype": "conference paper"}]},
            "item_1617605131499": {"attribute_name": "File","attribute_type": "file","attribute_value_mlt": [{"url": {"url": "https://localhost/record/1/files/test.txt"},"date": [{"dateType": "Available","dateValue": "2022-10-03"}],"format": "text/tab-separated-values","filename": "check_2022-03-10.tsv","filesize": [{"value": "460 B"}],"accessrole": "open_access","version_id": "29dd361d-dc7f-49bc-b471-bdb5752afef5","displaytype": "detail","licensetype": "license_12",}]}
        }
        record = record = WekoRecord.create(record_data, id_=rec_uuid1)
        mapping_data = MappingData(record=record)
        # identifier_type = JaLC, not exist error
>       result = handle_check_required_pattern_and_either(mapping_data,["dc:title"],"1")

tests/test_utils.py:417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapping_data = <weko_workflow.utils.MappingData object at 0x7fa9b5b72390>
mapping_keys = ['dc:title'], error_list = '1', is_either = False

    def handle_check_required_pattern_and_either(mapping_data, mapping_keys,
                                                 error_list=None, is_either=False):
        """Check required, pattern and either required."""
        if not (mapping_data and mapping_keys):
            return
        if not error_list:
            error_list = {'required': [], 'required_key': [], 'pattern': [],
                          'either': [], 'either_key': [], 'mapping': []}
        empty_list = deepcopy(error_list)
        keys = []
        num_map = 0
        requirements = []
        for mapping_key in mapping_keys:
            for elem, pattern in DOI_VALIDATION_INFO[mapping_key]:
                check_required_info = handle_check_required_data(
                    mapping_data, elem)
                if not check_required_info[1]:
                    error_list['mapping'].append(mapping_key)
                    continue
    
                keys.extend(check_required_info[1])
                requirements.extend(check_required_info[0])
                if num_map == 0:
                    num_map = len(check_required_info[1])
                if pattern and check_required_info[2]:
                    for idx, values in enumerate(check_required_info[2]):
                        if values and pattern not in values:
                            error_list['pattern'].append(
                                check_required_info[1][idx])
    
        if requirements:
            if num_map == 1 and not is_either:
>               error_list['required'].extend(requirements)
E               TypeError: string indices must be integers

weko_workflow/utils.py:610: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________________ test_delete_bucket ______________________________

self = <sqlalchemy.engine.base.Connection object at 0x7fa9b34dfda0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b362bf28>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2'>>
statement = 'DELETE FROM files_bucket WHERE files_bucket.id = %(id_1)s'
parameters = {'id_1': UUID('f9a70a0a-310c-4997-9ae0-89d1fd987fdb')}
args = (<sqlalchemy.dialects.postgresql.psycopg2.PGCompiler_psycopg2 object at 0x7fa9b3486550>, [{}])
conn = <sqlalchemy.pool._ConnectionFairy object at 0x7fa9b34cdb00>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9b3486630>

    def _execute_context(
        self, dialect, constructor, statement, parameters, *args
    ):
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`.ResultProxy`."""
    
        try:
            try:
                conn = self.__connection
            except AttributeError:
                # escape "except AttributeError" before revalidating
                # to prevent misleading stacktraces in Py3K
                conn = None
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(dialect, self, conn, *args)
        except BaseException as e:
            self._handle_dbapi_exception(
                e, util.text_type(statement), parameters, None, None
            )
    
        if context.compiled:
            context.pre_exec()
    
        cursor, statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        if not context.executemany:
            parameters = parameters[0]
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                statement, parameters = fn(
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self.engine.logger.info(statement)
            self.engine.logger.info(
                "%r", sql_util._repr_params(parameters, batches=10)
            )
    
        evt_handled = False
        try:
            if context.executemany:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor, statement, parameters, context
                    )
            elif not parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, statement, context
                    )
            else:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
>                       cursor, statement, parameters, context
                    )

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b362bf28>
cursor = <cursor object at 0x7fa9b4337520; closed: -1>
statement = 'DELETE FROM files_bucket WHERE files_bucket.id = %(id_1)s'
parameters = {'id_1': UUID('f9a70a0a-310c-4997-9ae0-89d1fd987fdb')}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9b3486630>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.IntegrityError: update or delete on table "files_bucket" violates foreign key constraint "fk_records_buckets_bucket_id_files_bucket" on table "records_buckets"
E       DETAIL:  Key (id)=(f9a70a0a-310c-4997-9ae0-89d1fd987fdb) is still referenced from table "records_buckets".

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: IntegrityError

The above exception was the direct cause of the following exception:

db_records = [(<PersistentIdentifier recid:1 / rec:582fb7a4-c35d-4ebc-8503-102e55cbfd3e (R)>, <PersistentIdentifier depid:1 / rec:5...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:6781f191-b4db-4bcc-aa8d-93876178da5b (R)>, None, ...)]
add_file = <function add_file.<locals>.factory at 0x7fa9b362de18>

    def test_delete_bucket(db_records, add_file):
        bucket,_ = add_file(db_records[2][2])
        bucket_id = bucket.id
>       delete_bucket(bucket_id)

tests/test_utils.py:578: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
weko_workflow/utils.py:1200: in delete_bucket
    bucket.remove()
../invenio-files-rest/invenio_files_rest/models.py:151: in inner
    return f(self, *args, **kwargs)
../invenio-files-rest/invenio_files_rest/models.py:588: in remove
    self.query.filter_by(id=self.id).delete()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:3440: in delete
    delete_op.exec_()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/persistence.py:1636: in exec_
    self._do_exec()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/persistence.py:1866: in _do_exec
    self._execute_stmt(delete_stmt)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/persistence.py:1642: in _execute_stmt
    stmt, params=self.query._params, mapper=self.mapper
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/session.py:1263: in execute
    clause, params or {}
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:980: in execute
    return meth(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/sql/elements.py:273: in _execute_on_connection
    return connection._execute_clauseelement(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1099: in _execute_clauseelement
    distilled_params,
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1240: in _execute_context
    e, statement, parameters, cursor, context
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1458: in _handle_dbapi_exception
    util.raise_from_cause(sqlalchemy_exception, exc_info)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:296: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:276: in reraise
    raise value.with_traceback(tb)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: in _execute_context
    cursor, statement, parameters, context
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9b362bf28>
cursor = <cursor object at 0x7fa9b4337520; closed: -1>
statement = 'DELETE FROM files_bucket WHERE files_bucket.id = %(id_1)s'
parameters = {'id_1': UUID('f9a70a0a-310c-4997-9ae0-89d1fd987fdb')}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9b3486630>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.IntegrityError) update or delete on table "files_bucket" violates foreign key constraint "fk_records_buckets_bucket_id_files_bucket" on table "records_buckets"
E       DETAIL:  Key (id)=(f9a70a0a-310c-4997-9ae0-89d1fd987fdb) is still referenced from table "records_buckets".
E        [SQL: 'DELETE FROM files_bucket WHERE files_bucket.id = %(id_1)s'] [parameters: {'id_1': UUID('f9a70a0a-310c-4997-9ae0-89d1fd987fdb')}] (Background on this error at: http://sqlalche.me/e/gkpj)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: IntegrityError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_________________________ test_set_bucket_default_size _________________________

db_records = [(<PersistentIdentifier recid:1 / rec:06da4c92-1f63-44c4-be64-24e09a313721 (R)>, <PersistentIdentifier depid:1 / rec:0...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:df8b9f47-56dd-42c4-9cf3-2983c1a75c4a (R)>, None, ...)]
add_file = <function add_file.<locals>.factory at 0x7fa9b2c99ea0>

    def test_set_bucket_default_size(db_records, add_file):
        bucket_10, rbucket_10 = add_file(db_records[2][2])
>       set_bucket_default_size(rbucket_10.id)
E       AttributeError: 'RecordsBuckets' object has no attribute 'id'

tests/test_utils.py:610: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_get_parent_pid_with_type _________________________

db_records = [(<PersistentIdentifier recid:1 / rec:41f7da40-8047-4035-b0fd-dc85f6381f85 (R)>, <PersistentIdentifier depid:1 / rec:4...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:16b34372-cc77-404b-804a-2e0e923d1999 (R)>, None, ...)]

    def test_get_parent_pid_with_type(db_records):
        result = get_parent_pid_with_type("doi",db_records[0][2].id)
        assert result == db_records[0][5]
    
>       result = get_parent_pid_with_type("hdl",db_records[4][2].id)

tests/test_utils.py:648: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pid_type = 'hdl', object_uuid = UUID('4d0962c5-4f25-4c55-b412-13d966a16db3')

    def get_parent_pid_with_type(pid_type, object_uuid):
        """Get Persistent Identifier Object by pid_value or item_uuid.
    
        Arguments:
            pid_type     -- {string} 'doi' (default) or 'hdl'
            object_uuid  -- {uuid} assigned object's uuid
    
        Returns:
            pid_object   -- PID object or None
    
        """
        try:
            record = WekoRecord.get_record(object_uuid)
            with db.session.no_autoflush:
                pid_object = PersistentIdentifier.query.filter_by(
                    pid_type=pid_type,
>                   object_uuid=record.pid_parent.object_uuid
                ).order_by(PersistentIdentifier.created.desc()).first()
E               AttributeError: 'NoneType' object has no attribute 'object_uuid'

weko_workflow/utils.py:1352: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_________________________ test_handle_finish_workflow __________________________

workflow = {'flow': <FlowDefine 1>, 'flow_action': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...], 'workflow': <WorkFlow 1>}
db_records = [(<PersistentIdentifier recid:1 / rec:8eee1a75-df0b-4905-b4c1-3f19598b14a4 (R)>, <PersistentIdentifier depid:1 / rec:8...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:dbf71cea-dae9-4597-8f1a-2443d606c90b (R)>, None, ...)]
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa9b35150f0>

    def test_handle_finish_workflow(workflow, db_records, mocker):
        result = handle_finish_workflow(None, None, None)
        assert result == None
        mocker.patch("weko_deposit.api.WekoDeposit.publish")
        mocker.patch("weko_deposit.api.WekoDeposit.commit")
>       mocker.patch("weko_workflow.utils.update_records_sets.delay")

tests/test_utils.py:738: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/pytest_mock/plugin.py:384: in __call__
    **kwargs
.tox/c1/lib/python3.6/site-packages/pytest_mock/plugin.py:183: in _start_patch
    mocked = p.start()  # type: unittest.mock.MagicMock
/usr/local/lib/python3.6/unittest/mock.py:1378: in start
    result = self.__enter__()
/usr/local/lib/python3.6/unittest/mock.py:1231: in __enter__
    self.target = self.getter()
/usr/local/lib/python3.6/unittest/mock.py:1401: in <lambda>
    getter = lambda: _importer(target)
/usr/local/lib/python3.6/unittest/mock.py:1088: in _importer
    thing = _dot_lookup(thing, comp, import_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

thing = <module 'weko_workflow.utils' from '/code/modules/weko-workflow/weko_workflow/utils.py'>
comp = 'update_records_sets'
import_path = 'weko_workflow.utils.update_records_sets'

    def _dot_lookup(thing, comp, import_path):
        try:
            return getattr(thing, comp)
        except AttributeError:
>           __import__(import_path)
E           ModuleNotFoundError: No module named 'weko_workflow.utils.update_records_sets'; 'weko_workflow.utils' is not a package

/usr/local/lib/python3.6/unittest/mock.py:1077: ModuleNotFoundError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________________ test_get_url_root _______________________________

app = <Flask 'testapp'>

    def test_get_url_root(app):
        app.config["THEME_SITEURL"] = "https://weko3.ir.rcos.nii.ac.jp"
        app.config["SERVER_NAME"] = "TEST_SERVER"
        with app.app_context():
>           assert get_url_root() == "https://weko3.ir.rcos.nii.ac.jp/"
E           AssertionError: assert 'http://TEST_SERVER.localdomain/' == 'https://weko3.ir.rcos.nii.ac.jp/'
E             - https://weko3.ir.rcos.nii.ac.jp/
E             + http://TEST_SERVER.localdomain/

tests/test_utils.py:829: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________________ test_get_item_info ______________________________

item_id = 'item_id'

    def get_item_info(item_id):
        """Get item info.
    
        :item_id: item id
        """
        if not item_id:
            return dict()
        try:
>           item = ItemsMetadata.get_record(id_=item_id)

weko_workflow/utils.py:2225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

_mock_self = <MagicMock name='get_record' id='140366719935656'>, args = ()
kwargs = {'id_': 'item_id'}

    def __call__(_mock_self, *args, **kwargs):
        # can't use self in-case a function / method we are mocking uses self
        # in the signature
        _mock_self._mock_check_sig(*args, **kwargs)
        _mock_self._increment_mock_call(*args, **kwargs)
>       return _mock_self._mock_call(*args, **kwargs)

.tox/c1/lib/python3.6/site-packages/mock/mock.py:1149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

_mock_self = <MagicMock name='get_record' id='140366719935656'>, args = ()
kwargs = {'id_': 'item_id'}

    def _mock_call(_mock_self, *args, **kwargs):
>       return _mock_self._execute_mock_call(*args, **kwargs)

.tox/c1/lib/python3.6/site-packages/mock/mock.py:1153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

_mock_self = <MagicMock name='get_record' id='140366719935656'>, args = ()
kwargs = {'id_': 'item_id'}
self = <MagicMock name='get_record' id='140366719935656'>
effect = Exception('test error',)

    def _execute_mock_call(_mock_self, *args, **kwargs):
        self = _mock_self
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: test error

.tox/c1/lib/python3.6/site-packages/mock/mock.py:1210: Exception

During handling of the above exception, another exception occurred:

db_records = [(<PersistentIdentifier recid:1 / rec:350a274f-f721-44e8-9ada-948f78d107cb (R)>, <PersistentIdentifier depid:1 / rec:3...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:84fceda6-4462-4689-a465-082e06eeefec (R)>, None, ...)]

    def test_get_item_info(db_records):
        result = get_item_info(db_records[0][3].id)
        assert result == {'type': 'depid', 'value': '1', 'revision_id': 0, 'email': 'wekosoftware@nii.ac.jp', 'username': '', 'displayname': '', 'resourceuri': 'http://purl.org/coar/resource_type/c_5794', 'resourcetype': 'conference paper', 'subitem_thumbnail': [{'thumbnail_url': '/api/files/29ad484d-4ed1-4caf-8b21-ab348ae7bf28/test.png?versionId=ecd5715e-4ca5-4e45-b93c-5089f52860a0', 'thumbnail_label': 'test.png'}]}
    
        with patch("weko_workflow.utils.ItemsMetadata.get_record",side_effect=Exception("test error")):
>           result = get_item_info("item_id")

tests/test_utils.py:1269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
weko_workflow/utils.py:2227: in get_item_info
    current_app.logger.exception('Cannot get item data:', ex)
/usr/local/lib/python3.6/logging/__init__.py:1343: in exception
    self.error(msg, *args, exc_info=exc_info, **kwargs)
/usr/local/lib/python3.6/logging/__init__.py:1337: in error
    self._log(ERROR, msg, args, **kwargs)
/usr/local/lib/python3.6/logging/__init__.py:1444: in _log
    self.handle(record)
/usr/local/lib/python3.6/logging/__init__.py:1454: in handle
    self.callHandlers(record)
/usr/local/lib/python3.6/logging/__init__.py:1516: in callHandlers
    hdlr.handle(record)
/usr/local/lib/python3.6/logging/__init__.py:865: in handle
    self.emit(record)
.tox/c1/lib/python3.6/site-packages/_pytest/logging.py:328: in emit
    super().emit(record)
/usr/local/lib/python3.6/logging/__init__.py:1000: in emit
    self.handleError(record)
/usr/local/lib/python3.6/logging/__init__.py:994: in emit
    msg = self.format(record)
/usr/local/lib/python3.6/logging/__init__.py:840: in format
    return fmt.format(record)
.tox/c1/lib/python3.6/site-packages/_pytest/logging.py:89: in format
    return super().format(record)
/usr/local/lib/python3.6/logging/__init__.py:577: in format
    record.message = record.getMessage()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <LogRecord: testapp, 40, /code/modules/weko-workflow/weko_workflow/utils.py, 2227, "Cannot get item data:">

    def getMessage(self):
        """
        Return the message for this LogRecord.
    
        Return the message for this LogRecord after merging any user-supplied
        arguments with the message.
        """
        msg = str(self.msg)
        if self.args:
>           msg = msg % self.args
E           TypeError: not all arguments converted during string formatting

/usr/local/lib/python3.6/logging/__init__.py:338: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__________________ test___init_activity_detail_data_for_guest __________________

self = <sqlalchemy.engine.base.Connection object at 0x7fa9ada50390>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9a86df278>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2'>>
statement = 'SELECT accounts_user.id AS accounts_user_id, accounts_user.email AS accounts_user_email, accounts_user.password AS ac...login_count AS accounts_user_login_count \nFROM accounts_user \nWHERE accounts_user.id = %(id_1)s \n LIMIT %(param_1)s'
parameters = {'id_1': 'dummy user', 'param_1': 1}
args = (<sqlalchemy.dialects.postgresql.psycopg2.PGCompiler_psycopg2 object at 0x7fa9ab449390>, [immutabledict({})])
conn = <sqlalchemy.pool._ConnectionFairy object at 0x7fa9adf53d68>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9ab449208>

    def _execute_context(
        self, dialect, constructor, statement, parameters, *args
    ):
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`.ResultProxy`."""
    
        try:
            try:
                conn = self.__connection
            except AttributeError:
                # escape "except AttributeError" before revalidating
                # to prevent misleading stacktraces in Py3K
                conn = None
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(dialect, self, conn, *args)
        except BaseException as e:
            self._handle_dbapi_exception(
                e, util.text_type(statement), parameters, None, None
            )
    
        if context.compiled:
            context.pre_exec()
    
        cursor, statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        if not context.executemany:
            parameters = parameters[0]
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                statement, parameters = fn(
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self.engine.logger.info(statement)
            self.engine.logger.info(
                "%r", sql_util._repr_params(parameters, batches=10)
            )
    
        evt_handled = False
        try:
            if context.executemany:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor, statement, parameters, context
                    )
            elif not parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, statement, context
                    )
            else:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
>                       cursor, statement, parameters, context
                    )

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9a86df278>
cursor = <cursor object at 0x7fa9be6c9dd8; closed: -1>
statement = 'SELECT accounts_user.id AS accounts_user_id, accounts_user.email AS accounts_user_email, accounts_user.password AS ac...login_count AS accounts_user_login_count \nFROM accounts_user \nWHERE accounts_user.id = %(id_1)s \n LIMIT %(param_1)s'
parameters = {'id_1': 'dummy user', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9ab449208>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.DataError: invalid input syntax for type integer: "dummy user"
E       LINE 3: WHERE accounts_user.id = 'dummy user' 
E                                        ^

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: DataError

The above exception was the direct cause of the following exception:

app = <Flask 'testapp'>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa9ae239c88>

    def test___init_activity_detail_data_for_guest(app,db,users,db_register,mocker):
        with app.test_request_context():
    
            activity = db_register["activities"][1]
            activity_id = activity.activity_id
            db_history1 = ActivityHistory(
                    activity_id=activity_id,
                    action_id=3,
                    action_user=users[0]["id"],
                    action_status="F",
                    action_date=datetime.datetime.strptime('2022/04/14 3:01:53.931', '%Y/%m/%d %H:%M:%S.%f'),
                    action_order=1
                )
            with db.session.begin_nested():
                db.session.add(db_history1)
    
            test_steps = [
                {"ActivityId":activity_id,"ActionId":1,"ActionName":"Start","ActionVersion":"1.0.0","ActionEndpoint":"begin_action","Author":"contributor@test.org","Status":"action_doing","ActionOrder":1},
                {"ActivityId":activity_id,"ActionId":3,"ActionName":"Item Registration","ActionVersion":"1.0.0","ActionEndpoint":"item_login","Author":"","Status":" ","ActionOrder":2},
                {"ActivityId":activity_id,"ActionId":5,"ActionName":"Item Link","ActionVersion":"1.0.0","ActionEndpoint":"item_link","Author":"","Status":" ","ActionOrder":3}
            ]
            action_endpoint = "begin_action"
            action_id=1
            activity_detail=activity
            cur_action=activity.action
            histories=[db_history1]
            item=ItemsMetadata.get_record(id_=activity.item_id)
            steps=test_steps,
            temporary_comment=None
            workflow_detail=db_register["workflow"]
            display_info = (action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)
            mocker.patch("weko_workflow.utils.get_activity_display_info",return_value=display_info)
            mocker.patch("weko_workflow.utils.get_approval_keys",return_value=[])
            community_id=""
            session['user_id'] = 'dummy user'
            session["guest_email"] = "guest@test.org"
            user_profile = {
                "results":{
                    'subitem_user_name': "guest",
                    'subitem_fullname': "guest",
                    'subitem_mail_address': "guest@test.org",
                    'subitem_displayname': "guest",
                    'subitem_university/institution': '',
                    'subitem_affiliated_division/department': '',
                    'subitem_position': '',
                    'subitem_phone_number': '',
                    'subitem_position(other)': '',
                    'subitem_affiliated_institution': [],
                }
            }
            test = dict(
                page=None,
                render_widgets=False,
                community_id=community_id,
                temporary_journal='',
                temporary_idf_grant='',
                temporary_idf_grant_suffix='',
                idf_grant_data='',
                idf_grant_input=IDENTIFIER_GRANT_LIST,
                idf_grant_method=0,
                error_type='item_login_error',
                cur_step=action_endpoint,
                approval_record=[],
                recid=None,
                links=None,
                term_and_condition_content='',
                is_auto_set_index_action=True,
                application_item_type=False,
                auto_fill_title="",
                auto_fill_data_type=None,
                is_show_autofill_metadata=True,
                is_hidden_pubdate=False,
                position_list=WEKO_USERPROFILES_POSITION_LIST,
                institute_position_list=WEKO_USERPROFILES_INSTITUTE_POSITION_LIST,
                item_type_name="テストアイテムタイプ",
                res_check=1,
                action_id=action_id,
                activity=activity_detail,
                histories=histories,
                item=item,
                steps=steps,
                temporary_comment=temporary_comment,
                workflow_detail=workflow_detail,
                user_profile=user_profile,
                list_license=[{'value': 'license_free', 'name': 'write your own license'}, {'value': 'license_12', 'name': 'Creative Commons CC0 1.0 Universal Public Domain Designation'}, {'value': 'license_6', 'name': 'Creative Commons Attribution 3.0 Unported (CC BY 3.0)'}, {'value': 'license_7', 'name': 'Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)'}, {'value': 'license_8', 'name': 'Creative Commons Attribution-NoDerivs 3.0 Unported (CC BY-ND 3.0)'}, {'value': 'license_9', 'name': 'Creative Commons Attribution-NonCommercial 3.0 Unported (CC BY-NC 3.0)'}, {'value': 'license_10', 'name': 'Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)'}, {'value': 'license_11', 'name': 'Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0)'}, {'value': 'license_0', 'name': 'Creative Commons Attribution 4.0 International (CC BY 4.0)'}, {'value': 'license_1', 'name': 'Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)'}, {'value': 'license_2', 'name': 'Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0)'}, {'value': 'license_3', 'name': 'Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)'}, {'value': 'license_4', 'name': 'Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)'}, {'value': 'license_5', 'name': 'Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)'}],
                cur_action=cur_action,
                activity_id=activity_detail.activity_id,
                is_enable_item_name_link=True,
                enable_feedback_maillist=current_app.config[
                    'WEKO_WORKFLOW_ENABLE_FEEDBACK_MAIL'],
                enable_contributor=current_app.config[
                    'WEKO_WORKFLOW_ENABLE_CONTRIBUTOR'],
                out_put_report_title="",
                action_endpoint_key={},
                approval_email_key=[],
                step_item_login_url="weko_items_ui/iframe/item_edit.html",
                need_file=True,
                need_billing_file=False,
                records={'id': '1.1', 'pid': {'type': 'depid', 'value': '1.1', 'revision_id': 0}, 'lang': 'ja', 'owner': '1', 'title': 'title', 'owners': [1], 'status': 'published', '$schema': '/items/jsonschema/15', 'pubdate': '2022-08-20', 'created_by': 1, 'owners_ext': {'email': 'wekosoftware@nii.ac.jp', 'username': '', 'displayname': ''}, 'shared_user_id': -1, 'item_1617186331708': [{'subitem_1551255647225': 'ff', 'subitem_1551255648112': 'ja'}], 'item_1617258105262': {'resourceuri': 'http://purl.org/coar/resource_type/c_5794', 'resourcetype': 'conference paper'}},
                record=[],
                jsonschema="/items/jsonschema/1",
                schemaform="/items/schemaform/1",
                item_save_uri="/items/iframe/model/save",
                files=[],
                endpoints={},
                need_thumbnail=False,
                files_thumbnail=[],
                allow_multi_thumbnail=False,
                id=db_register["workflow"].itemtype_id,
            )
    
            result = __init_activity_detail_data_for_guest(activity_id,community_id)
>           assert result == test

tests/test_utils.py:2249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/speaklater.py:163: in __eq__
    return self.value == other
.tox/c1/lib/python3.6/site-packages/speaklater.py:115: in <lambda>
    value = property(lambda x: x._func(*x._args, **x._kwargs))
.tox/c1/lib/python3.6/site-packages/flask_babelex/__init__.py:626: in gettext
    return get_domain().gettext(*args, **kwargs)
.tox/c1/lib/python3.6/site-packages/flask_babelex/__init__.py:533: in gettext
    t = self.get_translations()
.tox/c1/lib/python3.6/site-packages/invenio_i18n/babel.py:117: in get_translations
    locale = get_locale()
.tox/c1/lib/python3.6/site-packages/flask_babelex/__init__.py:220: in get_locale
    rv = babel.locale_selector_func()
.tox/c1/lib/python3.6/site-packages/invenio_i18n/selectors.py:56: in get_locale
    current_user.is_authenticated:
.tox/c1/lib/python3.6/site-packages/werkzeug/local.py:348: in __getattr__
    return getattr(self._get_current_object(), name)
.tox/c1/lib/python3.6/site-packages/werkzeug/local.py:307: in _get_current_object
    return self.__local()
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:26: in <lambda>
    current_user = LocalProxy(lambda: _get_user())
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:335: in _get_user
    current_app.login_manager._load_user()
.tox/c1/lib/python3.6/site-packages/flask_login/login_manager.py:359: in _load_user
    return self.reload_user()
.tox/c1/lib/python3.6/site-packages/flask_login/login_manager.py:321: in reload_user
    user = self.user_callback(user_id)
.tox/c1/lib/python3.6/site-packages/flask_security/core.py:221: in _user_loader
    return _security.datastore.find_user(id=user_id)
.tox/c1/lib/python3.6/site-packages/flask_security/datastore.py:254: in find_user
    return self.user_model.query.filter_by(**kwargs).first()
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:2979: in first
    ret = list(self[0:1])
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:2771: in __getitem__
    return list(res)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:3081: in __iter__
    return self._execute_and_instances(context)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/query.py:3106: in _execute_and_instances
    result = conn.execute(querycontext.statement, self._params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:980: in execute
    return meth(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/sql/elements.py:273: in _execute_on_connection
    return connection._execute_clauseelement(self, multiparams, params)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1099: in _execute_clauseelement
    distilled_params,
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1240: in _execute_context
    e, statement, parameters, cursor, context
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1458: in _handle_dbapi_exception
    util.raise_from_cause(sqlalchemy_exception, exc_info)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:296: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/util/compat.py:276: in reraise
    raise value.with_traceback(tb)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1236: in _execute_context
    cursor, statement, parameters, context
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fa9a86df278>
cursor = <cursor object at 0x7fa9be6c9dd8; closed: -1>
statement = 'SELECT accounts_user.id AS accounts_user_id, accounts_user.email AS accounts_user_email, accounts_user.password AS ac...login_count AS accounts_user_login_count \nFROM accounts_user \nWHERE accounts_user.id = %(id_1)s \n LIMIT %(param_1)s'
parameters = {'id_1': 'dummy user', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fa9ab449208>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.DataError: (psycopg2.DataError) invalid input syntax for type integer: "dummy user"
E       LINE 3: WHERE accounts_user.id = 'dummy user' 
E                                        ^
E        [SQL: 'SELECT accounts_user.id AS accounts_user_id, accounts_user.email AS accounts_user_email, accounts_user.password AS accounts_user_password, accounts_user.active AS accounts_user_active, accounts_user.confirmed_at AS accounts_user_confirmed_at, accounts_user.last_login_at AS accounts_user_last_login_at, accounts_user.current_login_at AS accounts_user_current_login_at, accounts_user.last_login_ip AS accounts_user_last_login_ip, accounts_user.current_login_ip AS accounts_user_current_login_ip, accounts_user.login_count AS accounts_user_login_count \nFROM accounts_user \nWHERE accounts_user.id = %(id_1)s \n LIMIT %(param_1)s'] [parameters: {'id_1': 'dummy user', 'param_1': 1}] (Background on this error at: http://sqlalche.me/e/9h9h)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/engine/default.py:536: DataError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_____________________ test_update_system_data_for_activity _____________________

db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    def test_update_system_data_for_activity(db_register):
        update_system_data_for_activity(None,None,None)
    
        key = "temp_key"
        value = {"data_key":"data_value"}
        activity = db_register["activities"][1]
        update_system_data_for_activity(activity,key,value)
>       assert activity.temp_data == {"metainfo":{key:value}}
E       assert '{"metainfo": {"temp_key": {"data_key": "data_value"}}}' == {'metainfo': {'temp_key': {'data_key': 'data_value'}}}
E         +'{"metainfo": {"temp_key": {"data_key": "data_value"}}}'
E         -{'metainfo': {'temp_key': {'data_key': 'data_value'}}}

tests/test_utils.py:2716: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________________ test_get_index_id _______________________________

    def test_get_index_id():
        """Get index ID base on activity id"""
        # from weko_workflow.api import WorkActivity, WorkFlow
    
        # activity = WorkActivity()
        # activity_detail = activity.get_activity_detail(activity_id)
    
        # workflow = WorkFlow()
        # workflow_detail = workflow.get_workflow_by_id(
        #     activity_detail.workflow_id)
    
        # index_tree_id = workflow_detail.index_tree_id
    
        # if index_tree_id:
        #     from .api import Indexes
        #     index_result = Indexes.get_index(index_tree_id)
        #     if not index_result:
        #         index_tree_id = None
        # else:
        #     index_tree_id = None
>       raise BaseException
E       BaseException

tests/test_utils.py:2778: BaseException
__________________________ test_make_activitylog_tsv ___________________________

db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
db_records = [(<PersistentIdentifier recid:1 / rec:994b9eb7-cee0-462c-b683-5a4e2913f0e4 (R)>, <PersistentIdentifier depid:1 / rec:9...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:f34a7f7d-46d3-4581-a459-b57b03a68a95 (R)>, None, ...)]

    def test_make_activitylog_tsv(db_register,db_records):
        """test make_activitylog_tsv"""
        activity = Activity()
        activities = []
        activities.append(activity.query.filter_by(activity_id='2'))
        activities.append(activity.query.filter_by(activity_id='3'))
    
    
>       output_tsv = make_activitylog_tsv(activities)

tests/test_utils.py:2788: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<flask_sqlalchemy.BaseQuery object at 0x7fa9a3d6ca58>, <flask_sqlalchemy.BaseQuery object at 0x7fa9a3d6c588>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'BaseQuery' object has no attribute 'activity_start'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
____________________________ test_index_acl_nologin ____________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_index_acl_nologin(client,db_register2):
        """_summary_
    
        Args:
            client (FlaskClient): flask test client
        """
        url = url_for('weko_workflow.index')
        res =  client.get(url)
        assert res.status_code == 302
>       assert res.location == url_for('security.login', next="/workflow/",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2F' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2F'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2F
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2F
E         ?        ^^^^ ^^^^^^

tests/test_views.py:67: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_____________________________ test_iframe_success ______________________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_records = [(<PersistentIdentifier recid:1 / rec:7d7000b2-deba-491e-a69a-45051c9cd543 (R)>, <PersistentIdentifier depid:1 / rec:7...type': 'conference paper'}}, <PersistentIdentifier recid:2 / rec:66a05c7c-343d-419c-bf97-9c0bf6935393 (R)>, None, ...)]
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa9a1d46f98>
without_remove_session = None

    def test_iframe_success(client, db_register,users, db_records,mocker,without_remove_session):
        mock_render_template = MagicMock(return_value=jsonify({}))
        item = db_records[0][3]
        session = {
            "itemlogin_id":"1",
            "itemlogin_activity":db_register["activities"][1],
            "itemlogin_item":item,
            "itemlogin_steps":"test steps",
            "itemlogin_action_id":3,
            "itemlogin_cur_step":"item_login",
            "itemlogin_record":"test approval_record",
            "itemlogin_histories":"test histories",
            "itemlogin_res_check":0,
            "itemlogin_pid":db_records[0][0],
            "itemlogin_community_id":"comm01"
        }
        mocker.patch("weko_workflow.views.session",session)
        with patch("weko_workflow.views.render_template", mock_render_template):
            url = url_for("weko_workflow.iframe_success")
            res = client.get(url)
            args, kwargs = mock_render_template.call_args
            assert args[0] == "weko_workflow/item_login_success.html"
>           assert "form" in kwargs
E           AssertionError: assert 'form' in {'action_comment': '', 'action_id': 3, 'activity': <Activity 4>, 'community': <Community, ID: comm01>, ...}

tests/test_views.py:137: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_init_activity_acl_nologin ________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_init_activity_acl_nologin(client,db_register2):
        """Test init_activity.
    
        Args:
            client (_type_): _description_
        """
    
        """"""
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': 1, 'flow_id': 1}
        res = client.post(url, json=input)
        assert res.status_code == 302
>       assert res.location == url_for('security.login', next="/workflow/activity/init",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Finit' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Finit'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Finit
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Finit
E         ?        ^^^^ ^^^^^^

tests/test_views.py:312: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__________________________ test_init_activity[0-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 0, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9ac8dfcc0>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa9a5dd1908> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 38, 25, 341061), 'updated': datetime.datetime(2023, 10, 9, 17, 38, 25, 341093), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '2', 'activity_update_user': '2', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 38, 25, 336179), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
__________________________ test_init_activity[1-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 1, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9a425be48>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa9a3c24390> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 38, 43, 982730), 'updated': datetime.datetime(2023, 10, 9, 17, 38, 43, 982740), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '4', 'activity_update_user': '4', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 38, 43, 978458), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
__________________________ test_init_activity[2-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 2, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9ac37ce48>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa9a2ff94a8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 39, 2, 400589), 'updated': datetime.datetime(2023, 10, 9, 17, 39, 2, 400600), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '5', 'activity_update_user': '5', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 39, 2, 393511), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
__________________________ test_init_activity[3-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 3, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9a1e4d1d0>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa9a1e56630> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 39, 22, 182130), 'updated': datetime.datetime(2023, 10, 9, 17, 39, 22, 182140), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '3', 'activity_update_user': '3', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 39, 22, 174976), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
__________________________ test_init_activity[4-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 4, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99ec21ef0>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa99eecf048> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 39, 41, 525729), 'updated': datetime.datetime(2023, 10, 9, 17, 39, 41, 525740), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '6', 'activity_update_user': '6', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 39, 41, 518570), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
__________________________ test_init_activity[5-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 5, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99e7d6c88>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa99e7ffb38> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 40, 0, 750632), 'updated': datetime.datetime(2023, 10, 9, 17, 40, 0, 750643), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '7', 'activity_update_user': '7', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 40, 0, 743351), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
__________________________ test_init_activity[6-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 6, status_code = 200
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_init_activity(client, users,users_index, status_code,db_register):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.init_activity')
        input = {'workflow_id': db_register['workflow'].id, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == status_code
    
        input = {'workflow_id': -99, 'flow_id': db_register['flow_define'].id}
        res = client.post(url, json=input)
        assert res.status_code == 500
    
>       input = {'workflow_id': db_register['workflow'].id, 'flow_id': -99}

tests/test_views.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0fa7748; WorkFlow>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9a1078eb8>
attribute_names = {'created', 'flow_id', 'flows_id', 'flows_name', 'id', 'index_tree_id', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <WorkFlow at 0x7fa9a10780f0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:528 sqlalchemy error: (psycopg2.IntegrityError) insert or update on table "workflow_activity" violates foreign key constraint "fk_workflow_activity_workflow_id_workflow_workflow"
DETAIL:  Key (workflow_id)=(-99) is not present in table "workflow_workflow".
 [SQL: 'INSERT INTO workflow_activity (status, created, updated, activity_id, activity_name, item_id, workflow_id, workflow_status, flow_id, action_id, action_status, activity_login_user, activity_update_user, activity_status, activity_start, activity_end, activity_community_id, activity_confirm_term_of_use, title, shared_user_id, temp_data, approval1, approval2, extra_info, action_order) VALUES (%(status)s, %(created)s, %(updated)s, %(activity_id)s, %(activity_name)s, %(item_id)s, %(workflow_id)s, %(workflow_status)s, %(flow_id)s, %(action_id)s, %(action_status)s, %(activity_login_user)s, %(activity_update_user)s, %(activity_status)s, %(activity_start)s, %(activity_end)s, %(activity_community_id)s, %(activity_confirm_term_of_use)s, %(title)s, %(shared_user_id)s, %(temp_data)s, %(approval1)s, %(approval2)s, %(extra_info)s, %(action_order)s) RETURNING workflow_activity.id'] [parameters: {'status': 'N', 'created': datetime.datetime(2023, 10, 9, 17, 40, 21, 248969), 'updated': datetime.datetime(2023, 10, 9, 17, 40, 21, 248984), 'activity_id': 'A-20231009-00002', 'activity_name': None, 'item_id': None, 'workflow_id': -99, 'workflow_status': None, 'flow_id': 1, 'action_id': 3, 'action_status': 'B', 'activity_login_user': '8', 'activity_update_user': '8', 'activity_status': 'M', 'activity_start': datetime.datetime(2023, 10, 9, 17, 40, 21, 243808), 'activity_end': None, 'activity_community_id': None, 'activity_confirm_term_of_use': True, 'title': None, 'shared_user_id': None, 'temp_data': '{}', 'approval1': None, 'approval2': None, 'extra_info': '{}', 'action_order': 2}] (Background on this error at: http://sqlalche.me/e/gkpj)
_______________________ test_previous_action_acl_nologin _______________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_previous_action_acl_nologin(client,db_register2):
        """Test of previous action."""
        url = url_for('weko_workflow.previous_action', activity_id='1',
                      action_id=1, req=1)
        input = {}
    
        res = client.post(url, json=input)
        assert res.status_code == 302
>       assert res.location == url_for('security.login',next="/workflow/activity/action/1/1/rejectOrReturn/1",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2FrejectOrReturn%2F1' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2FrejectOrReturn%2F1'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2FrejectOrReturn%2F1
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2FrejectOrReturn%2F1
E         ?        ^^^^ ^^^^^^

tests/test_views.py:601: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_________________________ test_previous_action[0-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 0, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_previous_action(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for("weko_workflow.previous_action",
                      activity_id="2",action_id=1,req=1)
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            res = client.post(url,json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        with patch("weko_workflow.views.ActionSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        input = {"action_version":"1.0.0", "commond":"this is test comment."}
    
        # req=1
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=1, req=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=0
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=-1
        res = previous_action(activity_id="2", action_id=1, req=-1)
        data = response_data(res[0])
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # not pre_action
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        with patch("weko_workflow.views.Flow.get_previous_flow_action", return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        # not exist activity_detail
        url = url_for('weko_workflow.previous_action',
                      activity_id='1', action_id=1, req=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa998d272b0>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa998d274e0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1743 previous_action: argument error
ERROR    testapp:views.py:1749 previous_action: test error
_________________________ test_previous_action[3-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 3, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_previous_action(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for("weko_workflow.previous_action",
                      activity_id="2",action_id=1,req=1)
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            res = client.post(url,json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        with patch("weko_workflow.views.ActionSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        input = {"action_version":"1.0.0", "commond":"this is test comment."}
    
        # req=1
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=1, req=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=0
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=-1
        res = previous_action(activity_id="2", action_id=1, req=-1)
        data = response_data(res[0])
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # not pre_action
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        with patch("weko_workflow.views.Flow.get_previous_flow_action", return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        # not exist activity_detail
        url = url_for('weko_workflow.previous_action',
                      activity_id='1', action_id=1, req=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1063: in decorated_function
    if check_authority_by_admin(activity_detail):
weko_workflow/utils.py:3725: in check_authority_by_admin
    if activity.activity_login_user in community_user_ids:
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa999285080>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa999285dd8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1743 previous_action: argument error
ERROR    testapp:views.py:1749 previous_action: test error
_________________________ test_previous_action[4-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 4, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_previous_action(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for("weko_workflow.previous_action",
                      activity_id="2",action_id=1,req=1)
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            res = client.post(url,json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        with patch("weko_workflow.views.ActionSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        input = {"action_version":"1.0.0", "commond":"this is test comment."}
    
        # req=1
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=1, req=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=0
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=-1
        res = previous_action(activity_id="2", action_id=1, req=-1)
        data = response_data(res[0])
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # not pre_action
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        with patch("weko_workflow.views.Flow.get_previous_flow_action", return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        # not exist activity_detail
        url = url_for('weko_workflow.previous_action',
                      activity_id='1', action_id=1, req=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99ca63ef0>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa99ca63f60> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1743 previous_action: argument error
ERROR    testapp:views.py:1749 previous_action: test error
_________________________ test_previous_action[5-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 5, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_previous_action(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for("weko_workflow.previous_action",
                      activity_id="2",action_id=1,req=1)
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            res = client.post(url,json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        with patch("weko_workflow.views.ActionSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code==500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        input = {"action_version":"1.0.0", "commond":"this is test comment."}
    
        # req=1
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=1, req=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=0
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code==status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # req=-1
        res = previous_action(activity_id="2", action_id=1, req=-1)
        data = response_data(res[0])
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # not pre_action
        url = url_for('weko_workflow.previous_action',
                      activity_id='2', action_id=3, req=0)
        with patch("weko_workflow.views.Flow.get_previous_flow_action", return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        # not exist activity_detail
        url = url_for('weko_workflow.previous_action',
                      activity_id='1', action_id=1, req=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99bc904e0>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa99bc90320> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1743 previous_action: argument error
ERROR    testapp:views.py:1749 previous_action: test error
_________________________ test_next_action_acl_nologin _________________________

client = <FlaskClient <Flask 'testapp'>>
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}

    def test_next_action_acl_nologin(client, db_register_fullaction):
        """Test of next action."""
        url = url_for('weko_workflow.next_action', activity_id='1',
                      action_id=1)
        input = {}
    
        res = client.post(url, json=input)
        assert res.status_code == 302
>       assert res.location == url_for('security.login',next="/workflow/activity/action/1/1",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1
E         ?        ^^^^ ^^^^^^

tests/test_views.py:780: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
___________________________ test_next_action[0-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa993ab49b0> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa993a9c940>, None, ...)]
users_index = 0, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa993a61c88>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa993a46828>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa993a400b8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
___________________________ test_next_action[1-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa9935da630> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa99353ddd8>, None, ...)]
users_index = 1, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa99355fd68>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get activity detail"
    
        # cannot get schema
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.get_schema_action",return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == "can not get schema by action_id"
    
        # request_body error
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        update_activity_order("2",7,5)
        input = {
            "temporary_save":1,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
        }
        res = client.post(url,json=input)
        data = response_data(res)
        assert res.status_code==500
        assert data["code"] == -1
        assert data["msg"] == "{'identifier_grant_ndl_jalc_doi_suffix': ['Missing data for required field.']}"
    
        # action: start
        input = {}
        url = url_for("weko_workflow.next_action",
                      activity_id="1", action_id=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: end
        update_activity_order("2",2,7)
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=2)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # action: item register
        ## not exist pid_without_ver
        url = url_for("weko_workflow.next_action",
                      activity_id="1", action_id=3)
        update_activity_order("1",3,2)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 500
        assert data["code"] == -1
        assert data["msg"] == "can not get pid_without_ver"
        ## not exist record
        with patch("weko_workflow.views.WekoRecord.get_record_by_pid",return_value=None):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get record"
    
        with patch("weko_workflow.views.PersistentIdentifier.get_by_object",side_effect=PIDDoesNotExistError("recid","wrong value")):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get PersistentIdentifier"
        with patch("weko_workflow.views.WekoDeposit.get_record", return_value=None):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get pid_without_ver"
        ## template_save = 1
        ### not in journal
        update_activity_order("2",3,2)
        input = {"temporary_save":1}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=3)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ## temporary_save=0
        ###x activity action update faild
        with patch("weko_workflow.views.WorkActivity.upt_activity_action",return_value=False):
            update_activity_order("2",3,2)
            input = {"temporary_save":0}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == ""
    
        # action: oa policy
        ## temporary_save = 1
        ### in journal
        update_activity_order("2",6,3)
        input = {"temporary_save":1,
                 "journal":{"issn":"test issn"}}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=6)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ## temporary_save = 0
        update_activity_order("2",6,3)
        input = {"temporary_save":0,
                 "journal":{"issn":"test issn"}}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=6)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: item link
        ## temporary_save = 0
        ### exist pid_without_ver, exist link_data
        update_activity_order("2",5,4)
        input = {
            "temporary_save":0,
            "link_data":[
                {"item_id":"1","item_title":"test item1","sele_id":"relateTo"}
            ]
        }
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ####x raise except
        update_activity_order("2",5,4)
        err_msg = "test update error"
        with patch("weko_workflow.views.ItemLink.update",return_value=err_msg):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == err_msg
        ## temporary_save = 1
        update_activity_order("2",5,4)
        input = {
            "temporary_save":1,
            "link_data":[]
        }
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: identifier grant
        ## exist identifier_select
        ###x temporary_save = 1
        update_activity_order("2",7,5)
        input = {
            "temporary_save":1,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ### temporary_save = 0
        #### select NotGrant
        input = {
            "temporary_save":0,
            "identifier_grant":"0",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        update_activity_order("2",7,5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ###### not _old_v
        input = {
            "temporary_save":0,
            "identifier_grant":"0",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        with patch("weko_workflow.views.IdentifierHandle.get_idt_registration_data",return_value=(None, None)):
            update_activity_order("2",7,5)
            url = url_for("weko_workflow.next_action",
                    activity_id="2", action_id=7)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        ###### _old_v & _old_v = _new_v
        update_activity_order("7",7,5)
        url = url_for("weko_workflow.next_action",
                activity_id="7", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ##### item_id == pid_without_ver
        ###### _value
        update_activity_order("6",7,5)
        url = url_for("weko_workflow.next_action",
                activity_id="6", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ###### not _value
        with patch("weko_workflow.views.IdentifierHandle.get_idt_registration_data",return_value=(None,None)):
            update_activity_order("6",7,5)
            url = url_for("weko_workflow.next_action",
                    activity_id="6", action_id=7)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        #### select not Not_Grant
        #####x error_list is str
        input = {
            "temporary_save":0,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        test_msg = _('Cannot register selected DOI for current Item Type of this '
                     'item.')
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=test_msg):
            update_activity_order("2",7,5)
            res = client.post(url,json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == test_msg
    
        #####x error_list
        mock_previous_action = mocker.patch("weko_workflow.views.previous_action",return_value=make_response())
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=True):
            update_activity_order("2",7,5)
            res = client.post(url,json=input)
            assert res.status_code == status_code
            mock_previous_action.assert_called_with(
                activity_id="2",
                action_id=7,
                req=-1
            )
        ##### error_list is not str and error_list=False
        url = url_for("weko_workflow.next_action",
                activity_id="5", action_id=7)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("5",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ###### item_id
        ####### deposit and pid_without_ver and not recid
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ####### not (deposit and pid_without_ver and not recid)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            url = url_for("weko_workflow.next_action",
                activity_id="5", action_id=7)
            update_activity_order("5",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
    
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        ## not exist identifier_select & not temporary_save
        input = {
            "temporary_save":0,
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        ### _value and _type
        ####x error_list is str
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=test_msg):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] ==-1
            assert data["msg"] == test_msg
        ####x error_list is not str & error_list = True
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=True):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            assert res.status_code == status_code
            mock_previous_action.assert_called_with(
                activity_id="2",
                action_id=7,
                req=-1
            )
        #### error_list is not str & error_list = False
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ### not (_value and _type)
        url = url_for("weko_workflow.next_action",
                      activity_id="3", action_id=7)
        update_activity_order("3",7,5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"]==0
        assert data["msg"] == "success"
    
        ## next_action_handler is None
        activity_action = ActivityAction.query.filter_by(
            activity_id="2",
            action_id=4,
            action_order=6
        ).first()
        activity_action.action_handler=None
        db.session.merge(activity_action)
        db.session.commit()
        url = url_for("weko_workflow.next_action",
                      activity_id="2",action_id=7)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data=response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == "can not get next_action_handler"
        activity_action = ActivityAction.query.filter_by(
            activity_id="2",
            action_id=4,
            action_order=6
        ).first()
        activity_action.action_handler=-1
        db.session.merge(activity_action)
        db.session.commit()
    
        ## exist next_flow_action.action_roles
        flow_action_role = FlowActionRole(
>           flow_action_id=db_register_fullaction["flow_actions"][5].id,
            action_role=None,
            action_user=1
        )

tests/test_views.py:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f83b38; FlowAction>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99317ce48>
attribute_names = {'action_condition', 'action_date', 'action_id', 'action_order', 'action_status', 'action_version', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <FlowAction at 0x7fa99317cd68> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
ERROR    testapp:views.py:1224 next_action: can not get activity_detail
ERROR    testapp:views.py:1232 next_action: can not get schema by action_id
ERROR    testapp:views.py:1237 next_action: {'identifier_grant_ndl_jalc_doi_suffix': ['Missing data for required field.']}
ERROR    testapp:views.py:1298 next_action: can not get pid_without_ver
ERROR    testapp:views.py:1306 next_action: can not get record
ERROR    testapp:views.py:1290 can not get PersistentIdentifier
ERROR    testapp:views.py:1298 next_action: can not get pid_without_ver
ERROR    testapp:api.py:91 Traceback (most recent call last):
  File "/code/modules/weko-handle/weko_handle/api.py", line 62, in register_handle
    self.credential_path)
  File "/code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/b2handle/clientcredentials.py", line 54, in load_from_JSON
    jsonfilecontent = json.loads(open(json_filename, 'r').read())
TypeError: expected str, bytes or os.PathLike object, not NoneType

ERROR    testapp:api.py:92 expected str, bytes or os.PathLike object, not NoneType
ERROR    testapp:api.py:91 Traceback (most recent call last):
  File "/code/modules/weko-handle/weko_handle/api.py", line 62, in register_handle
    self.credential_path)
  File "/code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/b2handle/clientcredentials.py", line 54, in load_from_JSON
    jsonfilecontent = json.loads(open(json_filename, 'r').read())
TypeError: expected str, bytes or os.PathLike object, not NoneType

ERROR    testapp:api.py:92 expected str, bytes or os.PathLike object, not NoneType
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:views.py:1375 next_action: can not get next_action_handler
___________________________ test_next_action[2-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa992a9b0b8> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa992a48ef0>, None, ...)]
users_index = 2, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa992d6f940>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get activity detail"
    
        # cannot get schema
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.get_schema_action",return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == "can not get schema by action_id"
    
        # request_body error
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        update_activity_order("2",7,5)
        input = {
            "temporary_save":1,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
        }
        res = client.post(url,json=input)
        data = response_data(res)
        assert res.status_code==500
        assert data["code"] == -1
        assert data["msg"] == "{'identifier_grant_ndl_jalc_doi_suffix': ['Missing data for required field.']}"
    
        # action: start
        input = {}
        url = url_for("weko_workflow.next_action",
                      activity_id="1", action_id=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: end
        update_activity_order("2",2,7)
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=2)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # action: item register
        ## not exist pid_without_ver
        url = url_for("weko_workflow.next_action",
                      activity_id="1", action_id=3)
        update_activity_order("1",3,2)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 500
        assert data["code"] == -1
        assert data["msg"] == "can not get pid_without_ver"
        ## not exist record
        with patch("weko_workflow.views.WekoRecord.get_record_by_pid",return_value=None):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get record"
    
        with patch("weko_workflow.views.PersistentIdentifier.get_by_object",side_effect=PIDDoesNotExistError("recid","wrong value")):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get PersistentIdentifier"
        with patch("weko_workflow.views.WekoDeposit.get_record", return_value=None):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get pid_without_ver"
        ## template_save = 1
        ### not in journal
        update_activity_order("2",3,2)
        input = {"temporary_save":1}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=3)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ## temporary_save=0
        ###x activity action update faild
        with patch("weko_workflow.views.WorkActivity.upt_activity_action",return_value=False):
            update_activity_order("2",3,2)
            input = {"temporary_save":0}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == ""
    
        # action: oa policy
        ## temporary_save = 1
        ### in journal
        update_activity_order("2",6,3)
        input = {"temporary_save":1,
                 "journal":{"issn":"test issn"}}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=6)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ## temporary_save = 0
        update_activity_order("2",6,3)
        input = {"temporary_save":0,
                 "journal":{"issn":"test issn"}}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=6)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: item link
        ## temporary_save = 0
        ### exist pid_without_ver, exist link_data
        update_activity_order("2",5,4)
        input = {
            "temporary_save":0,
            "link_data":[
                {"item_id":"1","item_title":"test item1","sele_id":"relateTo"}
            ]
        }
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ####x raise except
        update_activity_order("2",5,4)
        err_msg = "test update error"
        with patch("weko_workflow.views.ItemLink.update",return_value=err_msg):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == err_msg
        ## temporary_save = 1
        update_activity_order("2",5,4)
        input = {
            "temporary_save":1,
            "link_data":[]
        }
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: identifier grant
        ## exist identifier_select
        ###x temporary_save = 1
        update_activity_order("2",7,5)
        input = {
            "temporary_save":1,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ### temporary_save = 0
        #### select NotGrant
        input = {
            "temporary_save":0,
            "identifier_grant":"0",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        update_activity_order("2",7,5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ###### not _old_v
        input = {
            "temporary_save":0,
            "identifier_grant":"0",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        with patch("weko_workflow.views.IdentifierHandle.get_idt_registration_data",return_value=(None, None)):
            update_activity_order("2",7,5)
            url = url_for("weko_workflow.next_action",
                    activity_id="2", action_id=7)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        ###### _old_v & _old_v = _new_v
        update_activity_order("7",7,5)
        url = url_for("weko_workflow.next_action",
                activity_id="7", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ##### item_id == pid_without_ver
        ###### _value
        update_activity_order("6",7,5)
        url = url_for("weko_workflow.next_action",
                activity_id="6", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ###### not _value
        with patch("weko_workflow.views.IdentifierHandle.get_idt_registration_data",return_value=(None,None)):
            update_activity_order("6",7,5)
            url = url_for("weko_workflow.next_action",
                    activity_id="6", action_id=7)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        #### select not Not_Grant
        #####x error_list is str
        input = {
            "temporary_save":0,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        test_msg = _('Cannot register selected DOI for current Item Type of this '
                     'item.')
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=test_msg):
            update_activity_order("2",7,5)
            res = client.post(url,json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == test_msg
    
        #####x error_list
        mock_previous_action = mocker.patch("weko_workflow.views.previous_action",return_value=make_response())
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=True):
            update_activity_order("2",7,5)
            res = client.post(url,json=input)
            assert res.status_code == status_code
            mock_previous_action.assert_called_with(
                activity_id="2",
                action_id=7,
                req=-1
            )
        ##### error_list is not str and error_list=False
        url = url_for("weko_workflow.next_action",
                activity_id="5", action_id=7)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("5",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ###### item_id
        ####### deposit and pid_without_ver and not recid
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ####### not (deposit and pid_without_ver and not recid)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            url = url_for("weko_workflow.next_action",
                activity_id="5", action_id=7)
            update_activity_order("5",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
    
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        ## not exist identifier_select & not temporary_save
        input = {
            "temporary_save":0,
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        ### _value and _type
        ####x error_list is str
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=test_msg):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] ==-1
            assert data["msg"] == test_msg
        ####x error_list is not str & error_list = True
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=True):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            assert res.status_code == status_code
            mock_previous_action.assert_called_with(
                activity_id="2",
                action_id=7,
                req=-1
            )
        #### error_list is not str & error_list = False
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ### not (_value and _type)
        url = url_for("weko_workflow.next_action",
                      activity_id="3", action_id=7)
        update_activity_order("3",7,5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"]==0
        assert data["msg"] == "success"
    
        ## next_action_handler is None
        activity_action = ActivityAction.query.filter_by(
            activity_id="2",
            action_id=4,
            action_order=6
        ).first()
        activity_action.action_handler=None
        db.session.merge(activity_action)
        db.session.commit()
        url = url_for("weko_workflow.next_action",
                      activity_id="2",action_id=7)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data=response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == "can not get next_action_handler"
        activity_action = ActivityAction.query.filter_by(
            activity_id="2",
            action_id=4,
            action_order=6
        ).first()
        activity_action.action_handler=-1
        db.session.merge(activity_action)
        db.session.commit()
    
        ## exist next_flow_action.action_roles
        flow_action_role = FlowActionRole(
>           flow_action_id=db_register_fullaction["flow_actions"][5].id,
            action_role=None,
            action_user=1
        )

tests/test_views.py:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f83b38; FlowAction>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa992799a20>
attribute_names = {'action_condition', 'action_date', 'action_id', 'action_order', 'action_status', 'action_version', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <FlowAction at 0x7fa992799fd0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
ERROR    testapp:views.py:1224 next_action: can not get activity_detail
ERROR    testapp:views.py:1232 next_action: can not get schema by action_id
ERROR    testapp:views.py:1237 next_action: {'identifier_grant_ndl_jalc_doi_suffix': ['Missing data for required field.']}
ERROR    testapp:views.py:1298 next_action: can not get pid_without_ver
ERROR    testapp:views.py:1306 next_action: can not get record
ERROR    testapp:views.py:1290 can not get PersistentIdentifier
ERROR    testapp:views.py:1298 next_action: can not get pid_without_ver
ERROR    testapp:api.py:91 Traceback (most recent call last):
  File "/code/modules/weko-handle/weko_handle/api.py", line 62, in register_handle
    self.credential_path)
  File "/code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/b2handle/clientcredentials.py", line 54, in load_from_JSON
    jsonfilecontent = json.loads(open(json_filename, 'r').read())
TypeError: expected str, bytes or os.PathLike object, not NoneType

ERROR    testapp:api.py:92 expected str, bytes or os.PathLike object, not NoneType
ERROR    testapp:api.py:91 Traceback (most recent call last):
  File "/code/modules/weko-handle/weko_handle/api.py", line 62, in register_handle
    self.credential_path)
  File "/code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/b2handle/clientcredentials.py", line 54, in load_from_JSON
    jsonfilecontent = json.loads(open(json_filename, 'r').read())
TypeError: expected str, bytes or os.PathLike object, not NoneType

ERROR    testapp:api.py:92 expected str, bytes or os.PathLike object, not NoneType
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:views.py:1375 next_action: can not get next_action_handler
___________________________ test_next_action[3-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa9928fc4a8> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa992805400>, None, ...)]
users_index = 3, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa994ec4128>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1063: in decorated_function
    if check_authority_by_admin(activity_detail):
weko_workflow/utils.py:3725: in check_authority_by_admin
    if activity.activity_login_user in community_user_ids:
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa994e44e48>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa994e69908> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
___________________________ test_next_action[4-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa998a9ef60> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa995e3eeb8>, None, ...)]
users_index = 4, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa9a1dff780>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99c652be0>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa99c6524a8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
___________________________ test_next_action[5-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa995649ef0> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa997208f98>, None, ...)]
users_index = 5, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa994b44d68>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
>           res = client.post(url, json=input)

tests/test_views.py:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9951fcb00>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa9955ba9e8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
___________________________ test_next_action[6-200] ____________________________

client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy engine=postgresql+psycopg2://invenio:***@postgresql:5432/wekotest>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa992918d30> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa9930d0b00>, None, ...)]
users_index = 6, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa993373da0>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_next_action(client, db, users, db_register_fullaction, db_records, users_index, status_code, mocker):
        def update_activity_order(activity_id, action_id, action_order):
            with db.session.begin_nested():
                activity=Activity.query.filter_by(activity_id=activity_id).one_or_none()
                activity.action_id=action_id
                activity.action_order=action_order
                db.session.merge(activity)
            db.session.commit()
        login(client=client, email=users[users_index]["email"])
        with client.session_transaction() as session:
            session['itemlogin_id'] = "test id"
            session['itemlogin_activity'] = "test activity"
            session['itemlogin_item'] = "test item"
            session['itemlogin_steps'] = "test steps"
            session['itemlogin_action_id'] = "test action_id"
            session['itemlogin_cur_step'] = "test cur_step"
            session['itemlogin_record'] = "test approval_record"
            session['itemlogin_histories'] = "test histories"
            session['itemlogin_res_check'] = "test res_check"
            session['itemlogin_pid'] = "test recid"
            session['itemlogin_community_id'] = "test community_id"
    
        mocker.patch("weko_workflow.views.IdentifierHandle.remove_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.IdentifierHandle.update_idt_registration_metadata",return_value=None)
        mocker.patch("weko_workflow.views.WekoDeposit.update_feedback_mail")
        mocker.patch("weko_workflow.views.FeedbackMailList.update_by_list_item_id")
        mocker.patch("weko_workflow.views.FeedbackMailList.delete_by_list_item_id")
        mock_signal = mocker.patch("weko_workflow.views.item_created.send")
        new_item = uuid.uuid4()
        mocker.patch("weko_workflow.views.handle_finish_workflow",return_value=new_item)
    
    
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            input = {}
            url = url_for("weko_workflow.next_action",
                          activity_id="1", action_id=1)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # can not get activity_detail
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register_fullaction["activities"][0],None]):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get activity detail"
    
        # cannot get schema
        url = url_for("weko_workflow.next_action",
                activity_id="1", action_id=1)
        with patch("weko_workflow.views.get_schema_action",return_value=None):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == "can not get schema by action_id"
    
        # request_body error
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        update_activity_order("2",7,5)
        input = {
            "temporary_save":1,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
        }
        res = client.post(url,json=input)
        data = response_data(res)
        assert res.status_code==500
        assert data["code"] == -1
        assert data["msg"] == "{'identifier_grant_ndl_jalc_doi_suffix': ['Missing data for required field.']}"
    
        # action: start
        input = {}
        url = url_for("weko_workflow.next_action",
                      activity_id="1", action_id=1)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: end
        update_activity_order("2",2,7)
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=2)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
    
        # action: item register
        ## not exist pid_without_ver
        url = url_for("weko_workflow.next_action",
                      activity_id="1", action_id=3)
        update_activity_order("1",3,2)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 500
        assert data["code"] == -1
        assert data["msg"] == "can not get pid_without_ver"
        ## not exist record
        with patch("weko_workflow.views.WekoRecord.get_record_by_pid",return_value=None):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get record"
    
        with patch("weko_workflow.views.PersistentIdentifier.get_by_object",side_effect=PIDDoesNotExistError("recid","wrong value")):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get PersistentIdentifier"
        with patch("weko_workflow.views.WekoDeposit.get_record", return_value=None):
            update_activity_order("2",3,2)
            input = {"temporary_save":1}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "can not get pid_without_ver"
        ## template_save = 1
        ### not in journal
        update_activity_order("2",3,2)
        input = {"temporary_save":1}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=3)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ## temporary_save=0
        ###x activity action update faild
        with patch("weko_workflow.views.WorkActivity.upt_activity_action",return_value=False):
            update_activity_order("2",3,2)
            input = {"temporary_save":0}
            url = url_for("weko_workflow.next_action",
                          activity_id="2", action_id=3)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == ""
    
        # action: oa policy
        ## temporary_save = 1
        ### in journal
        update_activity_order("2",6,3)
        input = {"temporary_save":1,
                 "journal":{"issn":"test issn"}}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=6)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ## temporary_save = 0
        update_activity_order("2",6,3)
        input = {"temporary_save":0,
                 "journal":{"issn":"test issn"}}
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=6)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == 200
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: item link
        ## temporary_save = 0
        ### exist pid_without_ver, exist link_data
        update_activity_order("2",5,4)
        input = {
            "temporary_save":0,
            "link_data":[
                {"item_id":"1","item_title":"test item1","sele_id":"relateTo"}
            ]
        }
        url = url_for("weko_workflow.next_action",
                      activity_id="2", action_id=5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ####x raise except
        update_activity_order("2",5,4)
        err_msg = "test update error"
        with patch("weko_workflow.views.ItemLink.update",return_value=err_msg):
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == err_msg
        ## temporary_save = 1
        update_activity_order("2",5,4)
        input = {
            "temporary_save":1,
            "link_data":[]
        }
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        # action: identifier grant
        ## exist identifier_select
        ###x temporary_save = 1
        update_activity_order("2",7,5)
        input = {
            "temporary_save":1,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ### temporary_save = 0
        #### select NotGrant
        input = {
            "temporary_save":0,
            "identifier_grant":"0",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        update_activity_order("2",7,5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ###### not _old_v
        input = {
            "temporary_save":0,
            "identifier_grant":"0",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        with patch("weko_workflow.views.IdentifierHandle.get_idt_registration_data",return_value=(None, None)):
            update_activity_order("2",7,5)
            url = url_for("weko_workflow.next_action",
                    activity_id="2", action_id=7)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        ###### _old_v & _old_v = _new_v
        update_activity_order("7",7,5)
        url = url_for("weko_workflow.next_action",
                activity_id="7", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
        ##### item_id == pid_without_ver
        ###### _value
        update_activity_order("6",7,5)
        url = url_for("weko_workflow.next_action",
                activity_id="6", action_id=7)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"] == 0
        assert data["msg"] == "success"
    
        ###### not _value
        with patch("weko_workflow.views.IdentifierHandle.get_idt_registration_data",return_value=(None,None)):
            update_activity_order("6",7,5)
            url = url_for("weko_workflow.next_action",
                    activity_id="6", action_id=7)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
        #### select not Not_Grant
        #####x error_list is str
        input = {
            "temporary_save":0,
            "identifier_grant":"1",
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        test_msg = _('Cannot register selected DOI for current Item Type of this '
                     'item.')
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=test_msg):
            update_activity_order("2",7,5)
            res = client.post(url,json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == test_msg
    
        #####x error_list
        mock_previous_action = mocker.patch("weko_workflow.views.previous_action",return_value=make_response())
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=True):
            update_activity_order("2",7,5)
            res = client.post(url,json=input)
            assert res.status_code == status_code
            mock_previous_action.assert_called_with(
                activity_id="2",
                action_id=7,
                req=-1
            )
        ##### error_list is not str and error_list=False
        url = url_for("weko_workflow.next_action",
                activity_id="5", action_id=7)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("5",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ###### item_id
        ####### deposit and pid_without_ver and not recid
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ####### not (deposit and pid_without_ver and not recid)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            url = url_for("weko_workflow.next_action",
                activity_id="5", action_id=7)
            update_activity_order("5",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
    
    
        url = url_for("weko_workflow.next_action",
                activity_id="2", action_id=7)
        ## not exist identifier_select & not temporary_save
        input = {
            "temporary_save":0,
            "identifier_grant_jalc_doi_suffix":"",
            "identifier_grant_jalc_cr_doi_suffix":"",
            "identifier_grant_jalc_dc_doi_suffix":"",
            "identifier_grant_ndl_jalc_doi_suffix":""
        }
        ### _value and _type
        ####x error_list is str
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=test_msg):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] ==-1
            assert data["msg"] == test_msg
        ####x error_list is not str & error_list = True
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=True):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            assert res.status_code == status_code
            mock_previous_action.assert_called_with(
                activity_id="2",
                action_id=7,
                req=-1
            )
        #### error_list is not str & error_list = False
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data = response_data(res)
            assert res.status_code == status_code
            assert data["code"] == 0
            assert data["msg"] == "success"
        ### not (_value and _type)
        url = url_for("weko_workflow.next_action",
                      activity_id="3", action_id=7)
        update_activity_order("3",7,5)
        res = client.post(url, json=input)
        data = response_data(res)
        assert res.status_code == status_code
        assert data["code"]==0
        assert data["msg"] == "success"
    
        ## next_action_handler is None
        activity_action = ActivityAction.query.filter_by(
            activity_id="2",
            action_id=4,
            action_order=6
        ).first()
        activity_action.action_handler=None
        db.session.merge(activity_action)
        db.session.commit()
        url = url_for("weko_workflow.next_action",
                      activity_id="2",action_id=7)
        with patch("weko_workflow.views.check_doi_validation_not_pass",return_value=False):
            update_activity_order("2",7,5)
            res = client.post(url, json=input)
            data=response_data(res)
            assert res.status_code == 500
            assert data["code"] == -2
            assert data["msg"] == "can not get next_action_handler"
        activity_action = ActivityAction.query.filter_by(
            activity_id="2",
            action_id=4,
            action_order=6
        ).first()
        activity_action.action_handler=-1
        db.session.merge(activity_action)
        db.session.commit()
    
        ## exist next_flow_action.action_roles
        flow_action_role = FlowActionRole(
>           flow_action_id=db_register_fullaction["flow_actions"][5].id,
            action_role=None,
            action_user=1
        )

tests/test_views.py:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f83b38; FlowAction>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa993078d30>
attribute_names = {'action_condition', 'action_date', 'action_id', 'action_order', 'action_status', 'action_version', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <FlowAction at 0x7fa993078da0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1216 next_action: argument error
ERROR    testapp:views.py:1224 next_action: can not get activity_detail
ERROR    testapp:views.py:1232 next_action: can not get schema by action_id
ERROR    testapp:views.py:1237 next_action: {'identifier_grant_ndl_jalc_doi_suffix': ['Missing data for required field.']}
ERROR    testapp:views.py:1298 next_action: can not get pid_without_ver
ERROR    testapp:views.py:1306 next_action: can not get record
ERROR    testapp:views.py:1290 can not get PersistentIdentifier
ERROR    testapp:views.py:1298 next_action: can not get pid_without_ver
ERROR    testapp:api.py:91 Traceback (most recent call last):
  File "/code/modules/weko-handle/weko_handle/api.py", line 62, in register_handle
    self.credential_path)
  File "/code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/b2handle/clientcredentials.py", line 54, in load_from_JSON
    jsonfilecontent = json.loads(open(json_filename, 'r').read())
TypeError: expected str, bytes or os.PathLike object, not NoneType

ERROR    testapp:api.py:92 expected str, bytes or os.PathLike object, not NoneType
ERROR    testapp:api.py:91 Traceback (most recent call last):
  File "/code/modules/weko-handle/weko_handle/api.py", line 62, in register_handle
    self.credential_path)
  File "/code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/b2handle/clientcredentials.py", line 54, in load_from_JSON
    jsonfilecontent = json.loads(open(json_filename, 'r').read())
TypeError: expected str, bytes or os.PathLike object, not NoneType

ERROR    testapp:api.py:92 expected str, bytes or os.PathLike object, not NoneType
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:utils.py:190 Identifier datas are empty!
ERROR    testapp:views.py:1375 next_action: can not get next_action_handler
________________________ test_cancel_action_acl_nologin ________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_cancel_action_acl_nologin(client,db_register2):
        """Test of cancel action."""
        url = url_for('weko_workflow.cancel_action',
                      activity_id='1', action_id=1)
        input = {'action_version': 1, 'commond': 1}
    
        res = client.post(url, json=input)
        assert res.status_code == 302
>       assert res.location == url_for('security.login', next="/workflow/activity/action/1/1/cancel",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2Fcancel' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2Fcancel'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2Fcancel
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Faction%2F1%2F1%2Fcancel
E         ?        ^^^^ ^^^^^^

tests/test_views.py:1567: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__________________________ test_cancel_action[0-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa990c20c88> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa990bccc50>, None, ...)]
add_file = <function add_file.<locals>.factory at 0x7fa990c30b70>
users_index = 0, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa990b90d30>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_cancel_action(client, users, db_register, db_records, add_file, users_index, status_code, mocker):
        login(client=client, email=users[users_index]['email'])
        #mocker.patch("weko_workflow.views.remove_file_cancel_action")
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            url = url_for('weko_workflow.cancel_action',
                      activity_id='1', action_id=1)
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        url = url_for('weko_workflow.cancel_action',
                  activity_id='1', action_id=1)
        with patch("weko_workflow.views.CancelSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        # can not get activity_detail
        input = {
            "action_version":"1.0.0",
            "commond":"this is test comment.",
            "pid_value":"1.1"
            }
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
            url = url_for('weko_workflow.cancel_action',
                          activity_id='1', action_id=1)
>           res = client.post(url, json=input)

tests/test_views.py:1687: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa99096e518>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa990bba1d0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1982 cancel_action: argument error
ERROR    testapp:views.py:1989 cancel_action: test error
__________________________ test_cancel_action[3-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa98f74a438> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa98f7405c0>, None, ...)]
add_file = <function add_file.<locals>.factory at 0x7fa98f738a60>
users_index = 3, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa98f7b1630>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_cancel_action(client, users, db_register, db_records, add_file, users_index, status_code, mocker):
        login(client=client, email=users[users_index]['email'])
        #mocker.patch("weko_workflow.views.remove_file_cancel_action")
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            url = url_for('weko_workflow.cancel_action',
                      activity_id='1', action_id=1)
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        url = url_for('weko_workflow.cancel_action',
                  activity_id='1', action_id=1)
        with patch("weko_workflow.views.CancelSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        # can not get activity_detail
        input = {
            "action_version":"1.0.0",
            "commond":"this is test comment.",
            "pid_value":"1.1"
            }
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
            url = url_for('weko_workflow.cancel_action',
                          activity_id='1', action_id=1)
>           res = client.post(url, json=input)

tests/test_views.py:1687: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1063: in decorated_function
    if check_authority_by_admin(activity_detail):
weko_workflow/utils.py:3725: in check_authority_by_admin
    if activity.activity_login_user in community_user_ids:
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa98f74aa20>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa98f754278> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1982 cancel_action: argument error
ERROR    testapp:views.py:1989 cancel_action: test error
__________________________ test_cancel_action[4-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa98f3852e8> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa98f368e10>, None, ...)]
add_file = <function add_file.<locals>.factory at 0x7fa98f505ae8>
users_index = 4, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa98f368eb8>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_cancel_action(client, users, db_register, db_records, add_file, users_index, status_code, mocker):
        login(client=client, email=users[users_index]['email'])
        #mocker.patch("weko_workflow.views.remove_file_cancel_action")
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            url = url_for('weko_workflow.cancel_action',
                      activity_id='1', action_id=1)
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        url = url_for('weko_workflow.cancel_action',
                  activity_id='1', action_id=1)
        with patch("weko_workflow.views.CancelSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        # can not get activity_detail
        input = {
            "action_version":"1.0.0",
            "commond":"this is test comment.",
            "pid_value":"1.1"
            }
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
            url = url_for('weko_workflow.cancel_action',
                          activity_id='1', action_id=1)
>           res = client.post(url, json=input)

tests/test_views.py:1687: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa98f394898>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa98f394828> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1982 cancel_action: argument error
ERROR    testapp:views.py:1989 cancel_action: test error
__________________________ test_cancel_action[5-200] ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
db_records = [(<[DetachedInstanceError('Instance <PersistentIdentifier at 0x7fa98ead1a58> is not bound to a Session; attribute refr...ibute refresh operation cannot proceed',) raised in repr()] PersistentIdentifier object at 0x7fa98ea375c0>, None, ...)]
add_file = <function add_file.<locals>.factory at 0x7fa98ebceae8>
users_index = 5, status_code = 200
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa98ea98a58>

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_cancel_action(client, users, db_register, db_records, add_file, users_index, status_code, mocker):
        login(client=client, email=users[users_index]['email'])
        #mocker.patch("weko_workflow.views.remove_file_cancel_action")
        # argument error
        with patch("weko_workflow.views.type_null_check",return_value=False):
            url = url_for('weko_workflow.cancel_action',
                      activity_id='1', action_id=1)
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "argument error"
    
        # request_body error
        url = url_for('weko_workflow.cancel_action',
                  activity_id='1', action_id=1)
        with patch("weko_workflow.views.CancelSchema",side_effect=ValidationError("test error")):
            res = client.post(url, json={})
            data = response_data(res)
            assert res.status_code == 500
            assert data["code"] == -1
            assert data["msg"] == "test error"
    
        # can not get activity_detail
        input = {
            "action_version":"1.0.0",
            "commond":"this is test comment.",
            "pid_value":"1.1"
            }
        with patch("weko_workflow.views.WorkActivity.get_activity_by_id",side_effect=[db_register["activities"][0],None]):
            url = url_for('weko_workflow.cancel_action',
                          activity_id='1', action_id=1)
>           res = client.post(url, json=input)

tests/test_views.py:1687: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1069: in decorated_function
    action_order=activity_detail.action_order
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f45550; Activity>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa98e6d74e0>
attribute_names = {'action_id', 'action_order', 'action_status', 'activity_community_id', 'activity_confirm_term_of_use', 'activity_end', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Activity at 0x7fa98e6d7518> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:1982 cancel_action: argument error
ERROR    testapp:views.py:1989 cancel_action: test error
_______________________ test_user_lock_activity_nologin ________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_user_lock_activity_nologin(client,db_register2):
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1',_external=False)

tests/test_views.py:1834: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98c83c588>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[0] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 0

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98c2e6198>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[1] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 1

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98bc51048>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[2] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 2

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98b6593c8>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[3] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 3

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98b0a37f0>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[4] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 4

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98aa706a0>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[5] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 5

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98ae80cf8>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
________________________ test_user_lock_activity_acl[6] ________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 6

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_lock_activity_acl(client, users, db_register2, users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98d0c5240>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
___________________________ test_user_lock_activity ____________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa98b3e2198>

    def test_user_lock_activity(client,db_register2, users, mocker):
        login(client=client, email=users[2]['email'])
        current_cache.delete("workflow_userlock_activity_5")
        mocker.patch("weko_workflow.views.validate_csrf_header")
>       url = url_for('weko_workflow.user_lock_activity', activity_id='1')

tests/test_views.py:1852: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98e4261d0>
endpoint = 'weko_workflow.user_lock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_lock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_user_unlock_activity_nologin _______________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_user_unlock_activity_nologin(client,db_register2):
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1',_external=False)

tests/test_views.py:1869: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa99d9f9780>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[0] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 0

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa9929f77b8>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[1] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 1

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98f0169e8>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[2] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 2

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98bf03518>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[3] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 3

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98fc786a0>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[4] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 4

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98a46c470>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[5] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 5

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa989f0dd68>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_user_unlock_activity_acl[6] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None, users_index = 6

    @pytest.mark.parametrize('users_index', [ i for i in range(7)])
    def test_user_unlock_activity_acl(client,users,db_register2,users_index):
        login(client=client, email=users[users_index]['email'])
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98990aac8>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__________________________ test_user_unlock_activity ___________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register2 = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa98cc90400>

    def test_user_unlock_activity(client,users,db_register2,mocker):
>       url = url_for('weko_workflow.user_unlock_activity', activity_id='1')

tests/test_views.py:1883: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:370: in url_for
    return appctx.app.handle_url_build_error(error, endpoint, values)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2215: in handle_url_build_error
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/helpers.py:358: in url_for
    endpoint, values, method=method, force_external=external
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.MapAdapter object at 0x7fa98cad57b8>
endpoint = 'weko_workflow.user_unlock_activity', values = {'activity_id': '1'}
method = None, force_external = False, append_unknown = True

    def build(
        self,
        endpoint,
        values=None,
        method=None,
        force_external=False,
        append_unknown=True,
    ):
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytestrings back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to unicode and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        .. versionadded:: 0.6
           the `append_unknown` parameter was added.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                temp_values = {}
                # iteritems(dict, values) is like `values.lists()`
                # without the call or `list()` coercion overhead.
                for key, value in iteritems(dict, values):
                    if not value:
                        continue
                    if len(value) == 1:  # flatten single item lists
                        value = value[0]
                        if value is None:  # drop None
                            continue
                    temp_values[key] = value
                values = temp_values
            else:
                # drop None
                values = dict(i for i in iteritems(values) if i[1] is not None)
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.BuildError: Could not build url for endpoint 'weko_workflow.user_unlock_activity' with values ['activity_id']. Did you mean 'weko_workflow.unlock_activity' instead?

.tox/c1/lib/python3.6/site-packages/werkzeug/routing.py:2181: BuildError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________________ test_lock_activity ______________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa987737c50>

    def test_lock_activity(client, users,db_register, mocker):
        """Test of lock activity."""
        mocker.patch("weko_workflow.views.validate_csrf_header")
        status_code = 200
        login(client=client, email=users[2]['email'])
    
        #regular
        url = url_for('weko_workflow.lock_activity', activity_id='A-00000003-00000')
        input = {'locked_value': '1-1661748792565'}
    
        with patch('weko_workflow.views.get_cache_data', return_value="1-1661748792565"):
            with patch('weko_workflow.views.update_cache_data'):
                res = client.post(url, data=input)
                assert res.status_code == status_code
>               assert json.loads(res.data) == {"code": 200, "err": "", "locked_by_email": "user@test.org", "locked_by_username": "", "locked_value": "1-1661748792565", "msg": "Success"}
E               AssertionError: assert {'code': 200,\n 'locked_by_email': 'user@test.org',\n 'locked_by_username': '',\n 'locked_value': '1-1661748792565',\n 'msg': 'Success'} == {'code': 200,\n 'err': '',\n 'locked_by_email': 'user@test.org',\n 'locked_by_username': '',\n 'locked_value': '1-1661748792565',\n 'msg': 'Success'}
E                 Common items:
E                 {'code': 200,
E                  'locked_by_email': 'user@test.org',
E                  'locked_by_username': '',
E                  'locked_value': '1-1661748792565',
E                  'msg': 'Success'}
E                 Right contains 1 more item:
E                 {'err': ''}
E                 Full diff:
E                   {
E                    'code': 200,
E                 -  'err': '',
E                    'locked_by_email': 'user@test.org',
E                    'locked_by_username': '',
E                    'locked_value': '1-1661748792565',
E                    'msg': 'Success',
E                   }

tests/test_views.py:1946: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_______________________ test_unlock_activity_acl_nologin _______________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_unlock_activity_acl_nologin(client,db_register2):
        """Test of unlock activity."""
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        res = client.post(url, json=input)
        assert res.status_code == 302
>       assert res.location == url_for('security.login',next="/workflow/activity/unlock/1",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Funlock%2F1' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Funlock%2F1'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Funlock%2F1
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Funlock%2F1
E         ?        ^^^^ ^^^^^^

tests/test_views.py:2068: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_________________________ test_unlock_activity[0-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 0, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_________________________ test_unlock_activity[1-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 1, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_________________________ test_unlock_activity[2-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 2, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_________________________ test_unlock_activity[3-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 3, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_________________________ test_unlock_activity[4-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 4, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_________________________ test_unlock_activity[5-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 5, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_________________________ test_unlock_activity[6-200] __________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 6, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_unlock_activity(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.unlock_activity', activity_id='1')
        input = {'locked_value':'1-1661748792565'}
    
        #check_flgの分岐テスト
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #cur_locked_valが空文字の場合
        with patch('weko_workflow.views.get_cache_data', return_value=""):
            res = client.post(url, json=input)
            data = json.loads(res.data.decode("utf-8"))
            assert res.status_code==status_code
            assert data["code"] == 200
            assert data["msg"] == 'Not unlock'
    
        #locked_valueが空でなく、cur_locked_valと一致する場合
        with patch('weko_workflow.views.get_cache_data', return_value='1-1661748792565'):
            with patch('weko_workflow.views.delete_cache_data'):
                res = client.post(url, json=input)
                data = json.loads(res.data.decode("utf-8"))
                assert res.status_code==status_code
                assert data["code"] == 200
>               assert data["msg"] == 'Unlock success'
E               AssertionError: assert 'Not unlock' == 'Unlock success'
E                 - Unlock success
E                 + Not unlock

tests/test_views.py:2126: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2493 unlock_activity: argument error
_______________________ test_check_approval_acl_nologin ________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_check_approval_acl_nologin(client,db_register2):
        """Test of check approval."""
        url = url_for('weko_workflow.check_approval', activity_id='1')
    
        res = client.get(url)
        assert res.status_code == 302
>       assert res.location == url_for('security.login',next="/workflow/check_approval/1",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Fcheck_approval%2F1' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Fcheck_approval%2F1'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Fcheck_approval%2F1
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Fcheck_approval%2F1
E         ?        ^^^^ ^^^^^^

tests/test_views.py:2142: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
____________________ test_get_feedback_maillist_acl_nologin ____________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_get_feedback_maillist_acl_nologin(client,db_register2):
        """Test of get feedback maillist."""
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
    
        res = client.get(url)
        assert res.status_code == 302
>       assert res.location == url_for('security.login',next="/workflow/get_feedback_maillist/1",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Fget_feedback_maillist%2F1' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Fget_feedback_maillist%2F1'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Fget_feedback_maillist%2F1
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Fget_feedback_maillist%2F1
E         ?        ^^^^ ^^^^^^

tests/test_views.py:2216: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_get_feedback_maillist[0-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 0, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa981de40f0>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa981de4198> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
______________________ test_get_feedback_maillist[1-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 1, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa98202e978>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa98202e1d0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
______________________ test_get_feedback_maillist[2-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 2, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa984f0c0f0>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa984f0c2e8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
______________________ test_get_feedback_maillist[3-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 3, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa98dfc6ba8>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa98dfc6b00> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
______________________ test_get_feedback_maillist[4-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 4, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9891acb38>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa9891ac780> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
______________________ test_get_feedback_maillist[5-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 5, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9868a1668>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa98718d9e8> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
______________________ test_get_feedback_maillist[6-200] _______________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users_index = 6, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 200),
        (1, 200),
        (2, 200),
        (3, 200),
        (4, 200),
        (5, 200),
        (6, 200),
    ])
    def test_get_feedback_maillist(client, users, db_register, users_index, status_code):
        login(client=client, email=users[users_index]['email'])
    
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        with patch('weko_workflow.views.type_null_check', return_value=False):
            res = client.get(url)
            data = response_data(res)
            assert res.status_code== 400
            assert data["code"] == -1
            assert data["msg"] == 'arguments error'
    
        #戻り値jsonify(code=0, msg=_('Empty!'))の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='1')
        res = client.get(url)
        data = response_data(res)
        assert res.status_code==status_code
        assert data['code'] == 0
        assert data['msg'] == 'Empty!'
    
        #戻り値jsonify(code=1,msg=_('Success'),data=mail_list)の分岐テスト
        url = url_for('weko_workflow.get_feedback_maillist', activity_id='4')
        res = client.get(url)
        data = response_data(res)
>       mail_list = db_register['action_feedback_mail'].feedback_maillist

tests/test_views.py:2267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:275: in __get__
    return self.impl.get(instance_state(instance), dict_)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/attributes.py:669: in get
    value = state._load_expired(state, passive)
.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/state.py:632: in _load_expired
    self.manager.deferred_scalar_loader(self, toload)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x7fa9c0f00668; ActionFeedbackMail>
state = <sqlalchemy.orm.state.InstanceState object at 0x7fa9843ac278>
attribute_names = {'action_id', 'activity_id', 'created', 'feedback_maillist', 'id', 'status', ...}

    def load_scalar_attributes(mapper, state, attribute_names):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
>               "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <ActionFeedbackMail at 0x7fa9843ac390> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)

.tox/c1/lib/python3.6/site-packages/sqlalchemy/orm/loading.py:913: DetachedInstanceError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:2291 get_feedback_maillist: argument error
________________________ test_save_activity_acl_nologin ________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_save_activity_acl_nologin(client,db_register2):
        """Test of save activity."""
        url = url_for('weko_workflow.save_activity')
        input = {"activity_id":"A-20220921-00001","title":"test","shared_user_id":-1}
    
        res = client.post(url, json=input)
        assert res.status_code == 302
>       assert res.location == url_for('security.login',next="/workflow/save_activity_data",_external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Fsave_activity_data' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Fsave_activity_data'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Fsave_activity_data
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Fsave_activity_data
E         ?        ^^^^ ^^^^^^

tests/test_views.py:2315: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
____________________________ test_display_activity _____________________________

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
mocker = <pytest_mock.plugin.MockerFixture object at 0x7fa9786610f0>
redis_connect = <simplekv.memory.redisstore.RedisStore object at 0x7fa9786509e8>
without_remove_session = None

    def test_display_activity(client, users, db_register,mocker,redis_connect,without_remove_session):
        def del_session():
            with client.session_transaction() as session:
                if session.get('activity_info'):
                    del session['activity_info']
                if session.get('itemlogin_id'):
                    del session['itemlogin_id']
                if session.get('itemlogin_activity'):
                    del session['itemlogin_activity']
                if session.get('itemlogin_item'):
                    del session['itemlogin_item']
                if session.get('itemlogin_steps'):
                    del session['itemlogin_steps']
                if session.get('itemlogin_action_id'):
                    del session['itemlogin_action_id']
                if session.get('itemlogin_cur_step'):
                    del session['itemlogin_cur_step']
                if session.get('itemlogin_record'):
                    del session['itemlogin_record']
                if session.get('itemlogin_res_check'):
                    del session['itemlogin_res_check']
                if session.get('itemlogin_pid'):
                    del session['itemlogin_pid']
                if session.get('itemlogin_community_id'):
                    del session['itemlogin_community_id']
        login(client=client, email=users[2]['email'])
    
        workflow_detail = WorkFlow.query.filter_by(id=1).one_or_none()
        mock_render_template = MagicMock(return_value=jsonify({}))
    
        activity_detail = Activity.query.filter_by(activity_id='A-00000001-10001').one_or_none()
        #activity_detail = Activity.query.filter_by(activity_id='1').one_or_none()
        cur_action = activity_detail.action
        action_endpoint = 'item_login'
        #action_endpoint = cur_action.action_endpoint
        action_id = cur_action.id
        histories = 1
        item_metadata = ItemMetadata()
        item_metadata.id = '37075580-8442-4402-beee-05f62e6e1dc2'
        # item_metadata = {'created':datetime.strptime("2022-09-22 05:09:54.677307", "%Y-%m-%d %H:%M:%S.%f"),'updated':datetime.strptime("2022-09-22 05:09:54.677307", "%Y-%m-%d %H:%M:%S.%f"),
        #                 'id':'37075580-8442-4402-beee-05f62e6e1dc2','item_type_id':15,'json': {"id": "1", "pid": {"type": "depid", "value": "1", "revision_id": 0}, "lang": "ja", "owner": "1", "title": "title", "owners": [1], "status": "published", "$schema": "/items/jsonschema/15", "pubdate": "2022-08-20", "created_by": 1, "owners_ext": {"email": "wekosoftware@nii.ac.jp", "username": "", "displayname": ""}, "shared_user_id": -1, "item_1617186331708": [{"subitem_1551255647225": "ff", "subitem_1551255648112": "ja"}], "item_1617258105262": {"resourceuri": "http://purl.org/coar/resource_type/c_5794", "resourcetype": "conference paper"}}
        #                 ,'version_id':3}
        item = None
        steps = 1
        temporary_comment = 1
    
    
        test_pid = PersistentIdentifier()
        test_pid.pid_value = '1'
        # test_pid= dict(created=datetime.strptime("2022-09-22 05:09:48.085724", "%Y-%m-%d %H:%M:%S.%f"),updated=datetime.strptime("2022-09-22 05:09:48.085747", "%Y-%m-%d %H:%M:%S.%f"),
        #             id=3, pid_type='recid',pid_value='1',pid_provider='',status='R',object_type='rec',object_uuid='37075580-8442-4402-beee-05f62e6e1dc2')
        test_comm= Community()
        test_comm.id = 'test'
        # test_comm=  dict(created=datetime.strptime("2022-09-22 05:09:48.085724", "%Y-%m-%d %H:%M:%S.%f"),updated=datetime.strptime("2022-09-22 05:09:48.085747", "%Y-%m-%d %H:%M:%S.%f"),
        #             id='test',id_role=1,id_user=1,title='test',description='',page='',curation_policy='',community_header='',community_footer='',last_record_accepted=datetime.strptime("2000-01-01 00:00:00", "%Y-%m-%d %H:%M:%S"),
        #             logo_ext='',ranking=0,fixed_points=0,deleted_at=None,root_node_id=1557819733276)
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        identifier = {'action_identifier_select': '',
                    'action_identifier_jalc_doi': '',
                    'action_identifier_jalc_cr_doi': '',
                    'action_identifier_jalc_dc_doi': '',
                    'action_identifier_ndl_jalc_doi': ''
                    }
    
    
        template_url = "weko_items_ui/iframe/item_edit.html"
        need_file = False
        need_billing_file = False
        record = {}
        json_schema = "test"
        schema_form = "test"
        item_save_uri = ""
        files = []
        endpoints = {}
        need_thumbnail = False
        files_thumbnail = []
        allow_multi_thumbnail = False
    
        license_list = []
        record_detail_alt = dict(
            record=None,
            files=None,
            files_thumbnail=None,
            pid=None)
    
        mocker.patch('weko_workflow.views.WorkActivity.get_activity_action_role',
                    return_value=(roles, action_users))
        mocker.patch('weko_workflow.views.WorkActivity.get_action_identifier_grant',return_value=identifier)
        mocker.patch('weko_workflow.views.check_authority_action',return_value=1)
        mocker.patch('weko_workflow.views.set_files_display_type',return_value=[])
        mocker.patch('weko_workflow.views.WorkActivity.get_action_journal')
        mocker.patch('weko_workflow.views.get_files_and_thumbnail',return_value=(["test1","test2"],files_thumbnail))
        mocker.patch('weko_workflow.views.get_usage_data')
        mocker.patch('weko_workflow.views.is_usage_application_item_type')
        mocker.patch('weko_theme.views.get_design_layout',return_value=(None,True))
        mocker.patch('weko_workflow.views.RedisConnection.connection',return_value=redis_connect)
    
        #regular
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = cur_action.action_endpoint
        item = None
    
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #activity_id is not String
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = cur_action.action_endpoint
        item = None
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.type_null_check',return_value=False):
                with patch('weko_workflow.views.item_login',return_value=(template_url,
                        need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                        files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                    with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                        with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                            with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                                with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                    with patch('weko_workflow.views.render_template', mock_render_template):
                                        res = client.post(url, query_string=input)
                                        mock_render_template.assert_called()
    
        #activity_id is include "?"
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-?10001')
        input = {}
        action_endpoint = cur_action.action_endpoint
        item = None
    
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #get_activity_display_info is include "None object"
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = None
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #action_endpoint is identifier_grant and item is not None
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'identifier_grant'
        item = item_metadata
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #action_endpoint is item_login and activity is None
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10002')
        input = {}
        action_endpoint = 'item_login'
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #template_url is None
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'item_login'
        template_url = None
    
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #Json_schema is None
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'item_login'
        template_url = "weko_items_ui/iframe/item_edit.html"
        json_schema = None
    
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #action_endpoint is identifier_grant and community is not root index
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {'community': 'test'}
        action_endpoint = 'identifier_grant'
        item = item_metadata
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,dict(test="test"))):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
        # not identifier_setting
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {'community': 'test'}
        action_endpoint = 'identifier_grant'
        item = item_metadata
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,dict(test="test"))):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    with patch("weko_workflow.views.get_identifier_setting", return_value=None):
                                        res = client.post(url, query_string=input)
                                        mock_render_template.assert_called()
    
        #action_endpoint is identifier_grant and community is not root index
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {'community': 'test'}
        action_endpoint = 'item_login'
        item = item_metadata
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record'):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
    
        #json_schema is not None
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'item_login'
        template_url = "weko_items_ui/iframe/item_edit.html"
        json_schema = "test"
    
        with patch('weko_workflow.views.get_activity_display_info',
                return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #item is not None
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'item_login'
        template_url = "weko_items_ui/iframe/item_edit.html"
        json_schema = "test"
        item = item_metadata
    
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.item_login',return_value=(template_url,
                    need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                    files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                    with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                        with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                            with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                with patch('weko_workflow.views.render_template', mock_render_template):
                                    res = client.post(url, query_string=input)
                                    mock_render_template.assert_called()
    
        #action_endpoint is item_link
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'item_link'
        template_url = "weko_items_ui/iframe/item_edit.html"
        json_schema = "test"
        item = item_metadata
    
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.ItemLink.get_item_link_info'):
                with patch('weko_workflow.views.item_login',return_value=(template_url,
                        need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                        files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                    with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                        with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                            with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                                with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                    with patch('weko_workflow.views.render_template', mock_render_template):
                                        res = client.post(url, query_string=input)
                                        mock_render_template.assert_called()
    
        #action_endpoint is item_login
        url = url_for('weko_workflow.display_activity', activity_id='A-00000001-10001')
        input = {}
        action_endpoint = 'item_login'
        template_url = "weko_items_ui/iframe/item_edit.html"
        json_schema = "test"
        item = item_metadata
        del_session()
        with client.session_transaction() as session:
            assert "itemlogin_id" not in session
        # locked_value is not existed
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.ItemLink.get_item_link_info'):
                with patch('weko_workflow.views.item_login',return_value=(template_url,
                        need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                        files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                    with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                        with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                            with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                                with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                    with patch('weko_workflow.views.render_template', mock_render_template):
                                        res = client.post(url, query_string=input)
                                        mock_render_template.assert_called()
                                        with client.session_transaction() as session:
                                            assert "itemlogin_id" in session
                                            assert "activity_info" in session
    
        # locked_value is existed
        del_session()
        with client.session_transaction() as session:
            assert "itemlogin_id" not in session
        current_cache.set("workflow_userlock_activity_5","A-00000001-10001")
        with patch('weko_workflow.views.get_activity_display_info',
                   return_value=(action_endpoint, action_id, activity_detail, cur_action, histories, item, \
                   steps, temporary_comment, workflow_detail)):
            with patch('weko_workflow.views.ItemLink.get_item_link_info'):
                with patch('weko_workflow.views.item_login',return_value=(template_url,
                        need_file,need_billing_file,record,json_schema,schema_form,item_save_uri,
                        files,endpoints,need_thumbnail,files_thumbnail,allow_multi_thumbnail)):
                    with patch('weko_workflow.views.get_pid_and_record',return_value=(test_pid,None)):
                        with patch('weko_workflow.views.GetCommunity.get_community_by_id',return_value=test_comm):
                            with patch('weko_records_ui.utils.get_list_licence',return_value=license_list):
                                with patch('weko_workflow.views.get_main_record_detail',return_value=record_detail_alt):
                                    with patch('weko_workflow.views.render_template', mock_render_template):
                                        res = client.post(url, query_string=input)
                                        mock_render_template.assert_called()
                                        with client.session_transaction() as session:
>                                           assert "itemlogin_id" not in session
E                                           AssertionError: assert 'itemlogin_id' not in <KVSession {'user_id': '5', '_permanent': True, '_fresh': False, 'csrf_token': 'c17a7c416e506de5cab72063cf1c629a22722a..., 'itemlogin_cur_step': 'item_login', 'itemlogin_res_check': 1, 'itemlogin_pid': <PersistentIdentifier None:1 (None)>}>

tests/test_views.py:2909: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
------------------------------ Captured log call -------------------------------
ERROR    testapp:views.py:744 display_activity: argument error
ERROR    testapp:views.py:756 display_activity: can not get activity display info
ERROR    testapp:views.py:850 display_activity: can not get item
ERROR    testapp:views.py:864 display_activity: can not get json_schema,schema_form
ERROR    testapp:views.py:864 display_activity: can not get json_schema,schema_form
________________________ test_withdraw_confirm_nologin _________________________

client = <FlaskClient <Flask 'testapp'>>, db_register2 = None

    def test_withdraw_confirm_nologin(client,db_register2):
        """Test of withdraw confirm."""
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                      action_id=1)
        input = {}
    
        res = client.post(url, json=input)
>       assert res.location == url_for('security.login',next="/workflow/activity/detail/1/1/withdraw",
                                        _external=True)
E       AssertionError: assert 'http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Fdetail%2F1%2F1%2Fwithdraw' == 'http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Fdetail%2F1%2F1%2Fwithdraw'
E         - http://test_server.localdomain/login/?next=%2Fworkflow%2Factivity%2Fdetail%2F1%2F1%2Fwithdraw
E         ?        ^^^^ ^^^^^^
E         + http://TEST_SERVER.localdomain/login/?next=%2Fworkflow%2Factivity%2Fdetail%2F1%2F1%2Fwithdraw
E         ?        ^^^^ ^^^^^^

tests/test_views.py:3076: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[0-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 0, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1084: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[1-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 1, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1064: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[2-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 2, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1064: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[3-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 3, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1084: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[4-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 4, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1084: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[5-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 5, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1084: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
__ test_withdraw_confirm_exception2[6-input_data2-500--1-bad identifier data] __

client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
users_index = 6, status_code = 500, input_data = {'passwd': 'DELETE'}, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    @pytest.mark.parametrize('users_index', [0, 1, 2, 3, 4, 5, 6])
    def test_withdraw_confirm_exception2(client, users, db_register_fullaction, users_index, status_code, input_data, code, msg):
        """Test of withdraw confirm."""
        login(client=client, email=users[users_index]['email'])
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
            return_value=(roles, action_users)):
>               res = client.post(url, json=input)

tests/test_views.py:3263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:148: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1064: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
_ test_withdraw_confirm_exception2_guestlogin[input_data2-500--1-bad identifier data] _

guest = <FlaskClient <Flask 'testapp'>>
client = <FlaskClient <Flask 'testapp'>>
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
db_register_fullaction = {'activities': [<Activity 1>, <Activity 4>, <Activity 5>, <Activity 6>, <Activity 7>, <Activity 8>, ...], 'flow_actions': [<FlowAction 1>, <FlowAction 2>, <FlowAction 3>, <FlowAction 4>, <FlowAction 5>, <FlowAction 6>, ...]}
input_data = {'passwd': 'DELETE'}, status_code = 500, code = -1
msg = 'bad identifier data'

    @pytest.mark.parametrize('input_data, status_code, code, msg', input_data_list)
    def test_withdraw_confirm_exception2_guestlogin(guest, client, users, db_register_fullaction, input_data, status_code, code, msg):
        """Test of withdraw confirm."""
        url = url_for('weko_workflow.withdraw_confirm', activity_id='1',
                action_id=2)
        input = input_data
        roles = {
            'allow': [],
            'deny': []
        }
        action_users = {
            'allow': [],
            'deny': []
        }
    
        with patch('weko_workflow.views.IdentifierHandle'):
            with patch('weko_workflow.views.WorkActivity.get_activity_action_role',
                return_value=(roles, action_users)):
>               res = guest.post(url, json=input)

tests/test_views.py:3288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1039: in post
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
../weko-accounts/weko_accounts/utils.py:146: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:1084: in decorated_function
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activity_id = '1', action_id = 2

    @workflow_blueprint.route(
        '/activity/detail/<string:activity_id>/<int:action_id>'
        '/withdraw',
        methods=['POST'])
    @login_required_customize
    @check_authority
    def withdraw_confirm(activity_id='0', action_id=0):
        """ユーザー情報を確認し、リダイレクト先のURLを返す。
        Args:
            activity_id (str, optional): 対象アクティビティID.パスパラメータから取得. Defaults to '0'.
            action_id (int, optional): 現在のアクションID.パスパラメータから取得. Defaults to 0.
    
        Returns:
            object: ユーザー情報の確認結果とリダイレクト先URLのjson dataをレスポンスボディにもつResponse. validated by ResponseMessageSchema
    
        Raises:
            marshmallow.exceptions.ValidationError: if ResponseMessageSchema is invalid.
    
        ---
        post:
            description: "withdraw confirm"
            security:
                - login_required_customize: []
                - check_authority: []
            requestBody:
                required: false
                content:
                    application/json:
                        schema:
                            PasswdSchema
                        example: {"passwd": "DELETE"}
            parameters:
                - in: path
                  name: activity_id
                  description: 対象のアクティビティID
                  schema:
                    type: string
                - in: path
                  name: action_id
                  description: 現在のアクションID
                  schema:
                    type: int
            responses:
                200:
                    description: "success"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": 0, "msg": "success", "data": {"redirect":"/workflow/activity/detail/1"}}
                500:
                    description: "server error"
                    content:
                        application/json:
                            schema:
                                ResponseMessageSchema
                            example:
                                {"code": -1, "msg": "argument error"}}
    
    
        """
        try:
            check_flg = type_null_check(activity_id, str)
            check_flg &= type_null_check(action_id, int)
            if not check_flg:
                current_app.logger.error("withdraw_confirm: argument error")
                res = ResponseMessageSchema().load({"code":-1, "msg":"argument error"})
                return jsonify(res.data), 500
    
            try:
                schema_load = PasswdSchema().load(request.get_json())
            except ValidationError as err:
                current_app.logger.error("withdraw_confirm: "+str(err))
                res = ResponseMessageSchema().load({"code":-1, "msg":str(err)})
                return jsonify(res.data), 500
            post_json = schema_load.data
    
            password = post_json.get('passwd', None)
            # wekouser = ShibUser()
            if password == 'DELETE':
                activity = WorkActivity()
                identifier_actionid = get_actionid('identifier_grant')
                identifier = activity.get_action_identifier_grant(
                    activity_id,
                    identifier_actionid)
                identifier['action_identifier_select'] = \
                    current_app.config.get(
>                       "WEKO_WORKFLOW_IDENTIFIER_GRANT_IS_WITHDRAWING", -2)
E                       TypeError: 'NoneType' object does not support item assignment

weko_workflow/views.py:2193: TypeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_download_activitylog_1[1-200] ______________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 1, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 403),
        (1, 200),
        (2, 200),
        (3, 403),
        (4, 403),
        (5, 403),
        (6, 200),
    ])
    def test_download_activitylog_1(client, db_register , users, users_index, status_code):
        """Test of download_activitylog."""
        login(client=client, email=users[users_index]['email'])
    
        #1
        url = url_for('weko_workflow.download_activitylog',
                    activity_id='2')
>       res = client.get(url)

tests/test_views.py:3387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:2741: in download_activitylog
    make_activitylog_tsv(activities),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<Activity 4>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'Activity' object has no attribute 'StatusDesc'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_download_activitylog_1[2-200] ______________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 2, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 403),
        (1, 200),
        (2, 200),
        (3, 403),
        (4, 403),
        (5, 403),
        (6, 200),
    ])
    def test_download_activitylog_1(client, db_register , users, users_index, status_code):
        """Test of download_activitylog."""
        login(client=client, email=users[users_index]['email'])
    
        #1
        url = url_for('weko_workflow.download_activitylog',
                    activity_id='2')
>       res = client.get(url)

tests/test_views.py:3387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:2741: in download_activitylog
    make_activitylog_tsv(activities),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<Activity 4>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'Activity' object has no attribute 'StatusDesc'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_download_activitylog_1[6-200] ______________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 6, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (0, 403),
        (1, 200),
        (2, 200),
        (3, 403),
        (4, 403),
        (5, 403),
        (6, 200),
    ])
    def test_download_activitylog_1(client, db_register , users, users_index, status_code):
        """Test of download_activitylog."""
        login(client=client, email=users[users_index]['email'])
    
        #1
        url = url_for('weko_workflow.download_activitylog',
                    activity_id='2')
>       res = client.get(url)

tests/test_views.py:3387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:2741: in download_activitylog
    make_activitylog_tsv(activities),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<Activity 4>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'Activity' object has no attribute 'StatusDesc'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_download_activitylog_2[1-200] ______________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 1, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (1, 200),
        (2, 200),
        (6, 200),
    ])
    def test_download_activitylog_2(client, db_register , users, users_index, status_code):
        """Test of download_activitylog."""
        login(client=client, email=users[users_index]['email'])
    
        #4
        url = url_for('weko_workflow.download_activitylog',
                    activity_id='2')
>       res = client.get(url)

tests/test_views.py:3413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:2741: in download_activitylog
    make_activitylog_tsv(activities),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<Activity 4>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'Activity' object has no attribute 'StatusDesc'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_download_activitylog_2[2-200] ______________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 2, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (1, 200),
        (2, 200),
        (6, 200),
    ])
    def test_download_activitylog_2(client, db_register , users, users_index, status_code):
        """Test of download_activitylog."""
        login(client=client, email=users[users_index]['email'])
    
        #4
        url = url_for('weko_workflow.download_activitylog',
                    activity_id='2')
>       res = client.get(url)

tests/test_views.py:3413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:2741: in download_activitylog
    make_activitylog_tsv(activities),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<Activity 4>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'Activity' object has no attribute 'StatusDesc'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
______________________ test_download_activitylog_2[6-200] ______________________

client = <FlaskClient <Flask 'testapp'>>
db_register = {'action_feedback_mail': <ActionFeedbackMail 2>, 'action_feedback_mail1': <ActionFeedbackMail 3>, 'action_feedback_mail2': <ActionFeedbackMail 4>, 'action_feedback_mail3': <ActionFeedbackMail 5>, ...}
users = [{'email': 'contributor@test.org', 'id': 2, 'obj': <User 2>}, {'email': 'repoadmin@test.org', 'id': 4, 'obj': <User 4>...eneraluser@test.org', 'id': 6, 'obj': <User 6>}, {'email': 'originalroleuser@test.org', 'id': 7, 'obj': <User 7>}, ...]
users_index = 6, status_code = 200

    @pytest.mark.parametrize('users_index, status_code', [
        (1, 200),
        (2, 200),
        (6, 200),
    ])
    def test_download_activitylog_2(client, db_register , users, users_index, status_code):
        """Test of download_activitylog."""
        login(client=client, email=users[users_index]['email'])
    
        #4
        url = url_for('weko_workflow.download_activitylog',
                    activity_id='2')
>       res = client.get(url)

tests/test_views.py:3413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1029: in get
    return self.open(*args, **kw)
.tox/c1/lib/python3.6/site-packages/flask/testing.py:227: in open
    follow_redirects=follow_redirects,
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:993: in open
    response = self.run_wsgi_app(environ.copy(), buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:884: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.tox/c1/lib/python3.6/site-packages/werkzeug/test.py:1119: in run_wsgi_app
    app_rv = app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2463: in __call__
    return self.wsgi_app(environ, start_response)
.tox/c1/lib/python3.6/site-packages/flask/app.py:2449: in wsgi_app
    response = self.handle_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1866: in handle_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:2446: in wsgi_app
    response = self.full_dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1951: in full_dispatch_request
    rv = self.handle_user_exception(e)
.tox/c1/lib/python3.6/site-packages/flask/app.py:1820: in handle_user_exception
    reraise(exc_type, exc_value, tb)
.tox/c1/lib/python3.6/site-packages/flask/_compat.py:39: in reraise
    raise value
.tox/c1/lib/python3.6/site-packages/flask/app.py:1949: in full_dispatch_request
    rv = self.dispatch_request()
.tox/c1/lib/python3.6/site-packages/flask/app.py:1935: in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
.tox/c1/lib/python3.6/site-packages/flask_login/utils.py:261: in decorated_view
    return func(*args, **kwargs)
weko_workflow/views.py:2741: in download_activitylog
    make_activitylog_tsv(activities),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

activities = [<Activity 4>]

    def make_activitylog_tsv(activities):
        """make tsv for activitiy_log
    
        Args:
            activities: activities for download as tsv.
        """
        import csv
        from io import StringIO
        file_output = StringIO()
    
        keys = current_app.config.get("WEKO_WORKFLOW_ACTIVITYLOG_XLS_COLUMNS")
    
        writer = csv.writer(file_output, delimiter="\t", lineterminator="\n")
        writer.writerow(keys)
        for item in activities:
            term = []
            for name in keys:
>               term.append(getattr(item,name))
E               AttributeError: 'Activity' object has no attribute 'StatusDesc'

weko_workflow/utils.py:4063: AttributeError
------------------------------ Captured log setup ------------------------------
WARNING  testapp:ext.py:255 JSONSCHEMAS_HOST is set to localhost
=============================== warnings summary ===============================
.tox/c1/lib/python3.6/site-packages/past/translation/__init__.py:35
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/past/translation/__init__.py:35: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
    import imp

.tox/c1/src/pypdf2/PyPDF2/generic.py:348
  /code/modules/weko-workflow/.tox/c1/src/pypdf2/PyPDF2/generic.py:348: DeprecationWarning: invalid escape sequence \c
    b_("c") : b_("\c"),

tests/test_admin.py::TestFlowSettingView::test_index_acl_guest
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/pkg_resources/_vendor/packaging/specifiers.py:276: DeprecationWarning: Creating a LegacyVersion has been deprecated and will be removed in the next major release
    DeprecationWarning,

tests/test_admin.py: 11352 warnings
tests/test_api.py: 3096 warnings
tests/test_cli.py: 1032 warnings
tests/test_romeo.py: 1548 warnings
tests/test_sessions.py: 516 warnings
tests/test_tasks.py: 516 warnings
tests/test_utils.py: 43344 warnings
tests/test_views.py: 159444 warnings
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/pkg_resources/_vendor/packaging/version.py:114: DeprecationWarning: Creating a LegacyVersion has been deprecated and will be removed in the next major release
    DeprecationWarning,

tests/test_admin.py: 22 warnings
tests/test_api.py: 6 warnings
tests/test_cli.py: 2 warnings
tests/test_romeo.py: 3 warnings
tests/test_sessions.py: 1 warning
tests/test_tasks.py: 1 warning
tests/test_utils.py: 84 warnings
tests/test_views.py: 309 warnings
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/flask_caching/__init__.py:241: DeprecationWarning: Using the initialization functions in flask_caching.backend is deprecated.  Use the a full path to backend classes directly.
    category=DeprecationWarning,

tests/test_admin.py: 572 warnings
tests/test_api.py: 156 warnings
tests/test_cli.py: 52 warnings
tests/test_romeo.py: 78 warnings
tests/test_sessions.py: 26 warnings
tests/test_tasks.py: 26 warnings
tests/test_utils.py: 2184 warnings
tests/test_views.py: 8034 warnings
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/invenio_admin/ext.py:73: PendingDeprecationWarning: Usage of model and modelview kwargs are deprecated in favor of view_class, args and kwargs.
    PendingDeprecationWarning

tests/test_admin.py: 22 warnings
tests/test_api.py: 6 warnings
tests/test_cli.py: 2 warnings
tests/test_romeo.py: 3 warnings
tests/test_sessions.py: 1 warning
tests/test_tasks.py: 1 warning
tests/test_utils.py: 84 warnings
tests/test_views.py: 309 warnings
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/flask_admin/model/base.py:1416: UserWarning: Fields missing from ruleset: created_userId,created_date,updated_userId,updated_date
    warnings.warn(text)

tests/test_utils.py::test_process_send_reminder_mail
  /code/modules/weko-workflow/.tox/c1/lib/python3.6/site-packages/sqlalchemy/dialects/postgresql/base.py:3258: SAWarning: Predicate of partial index uq_item_type_name_name ignored during reflection
    % idx_name

-- Docs: https://docs.pytest.org/en/stable/warnings.html

---------- coverage: platform linux, python 3.6.15-final-0 -----------
Name                                  Stmts   Miss Branch BrPart  Cover
-----------------------------------------------------------------------
weko_workflow/__init__.py                 4      0      0      0   100%
weko_workflow/admin.py                  223    101     72      8    52%
weko_workflow/api.py                   1218    424    416     84    62%
weko_workflow/bundles.py                 14      0      0      0   100%
weko_workflow/cli.py                    109     22     42     15    74%
weko_workflow/config.py                  90      0      0      0   100%
weko_workflow/errors.py                  18      0     10      0   100%
weko_workflow/ext.py                     21      1     10      2    90%
weko_workflow/models.py                 310     20     76      9    92%
weko_workflow/romeo.py                   22      0      0      0   100%
weko_workflow/schema/marshmallow.py      87      0     56      0   100%
weko_workflow/schema/utils.py            22      3     14      3    83%
weko_workflow/scopes.py                   6      0      0      0   100%
weko_workflow/sessions.py                13      5      4      1    53%
weko_workflow/tasks.py                    7      2      0      0    71%
weko_workflow/utils.py                 1886    464    838     92    73%
weko_workflow/version.py                  2      0      0      0   100%
weko_workflow/views.py                 1301    369    472     54    69%
-----------------------------------------------------------------------
TOTAL                                  5353   1411   2010    268    71%
Coverage HTML written to dir htmlcov
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED tests/test_admin.py::TestFlowSettingView::test_flow_detail_acl[1-200]
FAILED tests/test_admin.py::TestFlowSettingView::test_update_flow - Attribute...
FAILED tests/test_admin.py::TestFlowSettingView::test_new_flow - AttributeErr...
FAILED tests/test_admin.py::TestFlowSettingView::test_del_flow - AttributeErr...
FAILED tests/test_admin.py::TestFlowSettingView::test_get_actions - Assertion...
FAILED tests/test_admin.py::TestFlowSettingView::test_upt_flow_action - Attri...
FAILED tests/test_admin.py::TestWorkFlowSettingView::test_update_workflow_acl[1-200]
FAILED tests/test_admin.py::TestWorkFlowSettingView::test_save_workflow_role
FAILED tests/test_admin.py::TestWorkFlowSettingView::test_get_language_workflows
FAILED tests/test_api.py::test_WorkActivity_get_activity_index_search - sqlal...
FAILED tests/test_api.py::test_WorkActivity_upt_activity_detail - assert <Act...
FAILED tests/test_cli.py::test_init_workflow_tables - assert ('(psycopg2.Inte...
FAILED tests/test_utils.py::test_validation_item_property - TypeError: valida...
FAILED tests/test_utils.py::test_handle_check_required_pattern_and_either - T...
FAILED tests/test_utils.py::test_delete_bucket - sqlalchemy.exc.IntegrityErro...
FAILED tests/test_utils.py::test_set_bucket_default_size - AttributeError: 'R...
FAILED tests/test_utils.py::test_get_parent_pid_with_type - AttributeError: '...
FAILED tests/test_utils.py::test_handle_finish_workflow - ModuleNotFoundError...
FAILED tests/test_utils.py::test_get_url_root - AssertionError: assert 'http:...
FAILED tests/test_utils.py::test_get_item_info - TypeError: not all arguments...
FAILED tests/test_utils.py::test___init_activity_detail_data_for_guest - sqla...
FAILED tests/test_utils.py::test_update_system_data_for_activity - assert '{"...
FAILED tests/test_utils.py::test_get_index_id - BaseException
FAILED tests/test_utils.py::test_make_activitylog_tsv - AttributeError: 'Base...
FAILED tests/test_views.py::test_index_acl_nologin - AssertionError: assert '...
FAILED tests/test_views.py::test_iframe_success - AssertionError: assert 'for...
FAILED tests/test_views.py::test_init_activity_acl_nologin - AssertionError: ...
FAILED tests/test_views.py::test_init_activity[0-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_init_activity[1-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_init_activity[2-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_init_activity[3-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_init_activity[4-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_init_activity[5-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_init_activity[6-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_previous_action_acl_nologin - AssertionError...
FAILED tests/test_views.py::test_previous_action[0-200] - sqlalchemy.orm.exc....
FAILED tests/test_views.py::test_previous_action[3-200] - sqlalchemy.orm.exc....
FAILED tests/test_views.py::test_previous_action[4-200] - sqlalchemy.orm.exc....
FAILED tests/test_views.py::test_previous_action[5-200] - sqlalchemy.orm.exc....
FAILED tests/test_views.py::test_next_action_acl_nologin - AssertionError: as...
FAILED tests/test_views.py::test_next_action[0-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_next_action[1-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_next_action[2-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_next_action[3-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_next_action[4-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_next_action[5-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_next_action[6-200] - sqlalchemy.orm.exc.Deta...
FAILED tests/test_views.py::test_cancel_action_acl_nologin - AssertionError: ...
FAILED tests/test_views.py::test_cancel_action[0-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_cancel_action[3-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_cancel_action[4-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_cancel_action[5-200] - sqlalchemy.orm.exc.De...
FAILED tests/test_views.py::test_user_lock_activity_nologin - werkzeug.routin...
FAILED tests/test_views.py::test_user_lock_activity_acl[0] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity_acl[1] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity_acl[2] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity_acl[3] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity_acl[4] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity_acl[5] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity_acl[6] - werkzeug.routing...
FAILED tests/test_views.py::test_user_lock_activity - werkzeug.routing.BuildE...
FAILED tests/test_views.py::test_user_unlock_activity_nologin - werkzeug.rout...
FAILED tests/test_views.py::test_user_unlock_activity_acl[0] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity_acl[1] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity_acl[2] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity_acl[3] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity_acl[4] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity_acl[5] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity_acl[6] - werkzeug.routi...
FAILED tests/test_views.py::test_user_unlock_activity - werkzeug.routing.Buil...
FAILED tests/test_views.py::test_lock_activity - AssertionError: assert {'cod...
FAILED tests/test_views.py::test_unlock_activity_acl_nologin - AssertionError...
FAILED tests/test_views.py::test_unlock_activity[0-200] - AssertionError: ass...
FAILED tests/test_views.py::test_unlock_activity[1-200] - AssertionError: ass...
FAILED tests/test_views.py::test_unlock_activity[2-200] - AssertionError: ass...
FAILED tests/test_views.py::test_unlock_activity[3-200] - AssertionError: ass...
FAILED tests/test_views.py::test_unlock_activity[4-200] - AssertionError: ass...
FAILED tests/test_views.py::test_unlock_activity[5-200] - AssertionError: ass...
FAILED tests/test_views.py::test_unlock_activity[6-200] - AssertionError: ass...
FAILED tests/test_views.py::test_check_approval_acl_nologin - AssertionError:...
FAILED tests/test_views.py::test_get_feedback_maillist_acl_nologin - Assertio...
FAILED tests/test_views.py::test_get_feedback_maillist[0-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_get_feedback_maillist[1-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_get_feedback_maillist[2-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_get_feedback_maillist[3-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_get_feedback_maillist[4-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_get_feedback_maillist[5-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_get_feedback_maillist[6-200] - sqlalchemy.or...
FAILED tests/test_views.py::test_save_activity_acl_nologin - AssertionError: ...
FAILED tests/test_views.py::test_display_activity - AssertionError: assert 'i...
FAILED tests/test_views.py::test_withdraw_confirm_nologin - AssertionError: a...
FAILED tests/test_views.py::test_withdraw_confirm_exception2[0-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2[1-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2[2-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2[3-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2[4-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2[5-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2[6-input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_withdraw_confirm_exception2_guestlogin[input_data2-500--1-bad identifier data]
FAILED tests/test_views.py::test_download_activitylog_1[1-200] - AttributeErr...
FAILED tests/test_views.py::test_download_activitylog_1[2-200] - AttributeErr...
FAILED tests/test_views.py::test_download_activitylog_1[6-200] - AttributeErr...
FAILED tests/test_views.py::test_download_activitylog_2[1-200] - AttributeErr...
FAILED tests/test_views.py::test_download_activitylog_2[2-200] - AttributeErr...
FAILED tests/test_views.py::test_download_activitylog_2[6-200] - AttributeErr...
ERROR tests/test_tasks.py::test_cancel_expired_usage_report_activities - sqla...
==== 105 failed, 342 passed, 232836 warnings, 1 error in 8305.73s (2:18:25) ====
ERROR: InvocationError for command /code/modules/weko-workflow/.tox/c1/bin/pytest --cov=weko_workflow tests -v -s -vv --cov-branch --cov-report=term --cov-report=xml --cov-report=html --cov-config=tox.ini --basetemp=/code/modules/weko-workflow/.tox/c1/tmp (exited with code 1)
___________________________________ summary ____________________________________
ERROR:   c1: commands failed
